/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/dat.gui/build/dat.gui.module.js":
/*!******************************************************!*\
  !*** ./node_modules/dat.gui/build/dat.gui.module.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GUI: () => (/* binding */ GUI$1),\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   controllers: () => (/* binding */ controllers),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   dom: () => (/* binding */ dom$1),\n/* harmony export */   gui: () => (/* binding */ gui)\n/* harmony export */ });\n/**\n * dat-gui JavaScript Controller Library\n * https://github.com/dataarts/dat.gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction ___$insertStyle(css) {\n  if (!css) {\n    return;\n  }\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  var style = document.createElement('style');\n\n  style.setAttribute('type', 'text/css');\n  style.innerHTML = css;\n  document.head.appendChild(style);\n\n  return css;\n}\n\nfunction colorToString (color, forceCSSHex) {\n  var colorFormat = color.__state.conversionName.toString();\n  var r = Math.round(color.r);\n  var g = Math.round(color.g);\n  var b = Math.round(color.b);\n  var a = color.a;\n  var h = Math.round(color.h);\n  var s = color.s.toFixed(1);\n  var v = color.v.toFixed(1);\n  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {\n    var str = color.hex.toString(16);\n    while (str.length < 6) {\n      str = '0' + str;\n    }\n    return '#' + str;\n  } else if (colorFormat === 'CSS_RGB') {\n    return 'rgb(' + r + ',' + g + ',' + b + ')';\n  } else if (colorFormat === 'CSS_RGBA') {\n    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n  } else if (colorFormat === 'HEX') {\n    return '0x' + color.hex.toString(16);\n  } else if (colorFormat === 'RGB_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ']';\n  } else if (colorFormat === 'RGBA_ARRAY') {\n    return '[' + r + ',' + g + ',' + b + ',' + a + ']';\n  } else if (colorFormat === 'RGB_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + '}';\n  } else if (colorFormat === 'RGBA_OBJ') {\n    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';\n  } else if (colorFormat === 'HSV_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + '}';\n  } else if (colorFormat === 'HSVA_OBJ') {\n    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';\n  }\n  return 'unknown format';\n}\n\nvar ARR_EACH = Array.prototype.forEach;\nvar ARR_SLICE = Array.prototype.slice;\nvar Common = {\n  BREAK: {},\n  extend: function extend(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (!this.isUndefined(obj[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  defaults: function defaults(target) {\n    this.each(ARR_SLICE.call(arguments, 1), function (obj) {\n      var keys = this.isObject(obj) ? Object.keys(obj) : [];\n      keys.forEach(function (key) {\n        if (this.isUndefined(target[key])) {\n          target[key] = obj[key];\n        }\n      }.bind(this));\n    }, this);\n    return target;\n  },\n  compose: function compose() {\n    var toCall = ARR_SLICE.call(arguments);\n    return function () {\n      var args = ARR_SLICE.call(arguments);\n      for (var i = toCall.length - 1; i >= 0; i--) {\n        args = [toCall[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  },\n  each: function each(obj, itr, scope) {\n    if (!obj) {\n      return;\n    }\n    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {\n      obj.forEach(itr, scope);\n    } else if (obj.length === obj.length + 0) {\n      var key = void 0;\n      var l = void 0;\n      for (key = 0, l = obj.length; key < l; key++) {\n        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {\n          return;\n        }\n      }\n    } else {\n      for (var _key in obj) {\n        if (itr.call(scope, obj[_key], _key) === this.BREAK) {\n          return;\n        }\n      }\n    }\n  },\n  defer: function defer(fnc) {\n    setTimeout(fnc, 0);\n  },\n  debounce: function debounce(func, threshold, callImmediately) {\n    var timeout = void 0;\n    return function () {\n      var obj = this;\n      var args = arguments;\n      function delayed() {\n        timeout = null;\n        if (!callImmediately) func.apply(obj, args);\n      }\n      var callNow = callImmediately || !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(delayed, threshold);\n      if (callNow) {\n        func.apply(obj, args);\n      }\n    };\n  },\n  toArray: function toArray(obj) {\n    if (obj.toArray) return obj.toArray();\n    return ARR_SLICE.call(obj);\n  },\n  isUndefined: function isUndefined(obj) {\n    return obj === undefined;\n  },\n  isNull: function isNull(obj) {\n    return obj === null;\n  },\n  isNaN: function (_isNaN) {\n    function isNaN(_x) {\n      return _isNaN.apply(this, arguments);\n    }\n    isNaN.toString = function () {\n      return _isNaN.toString();\n    };\n    return isNaN;\n  }(function (obj) {\n    return isNaN(obj);\n  }),\n  isArray: Array.isArray || function (obj) {\n    return obj.constructor === Array;\n  },\n  isObject: function isObject(obj) {\n    return obj === Object(obj);\n  },\n  isNumber: function isNumber(obj) {\n    return obj === obj + 0;\n  },\n  isString: function isString(obj) {\n    return obj === obj + '';\n  },\n  isBoolean: function isBoolean(obj) {\n    return obj === false || obj === true;\n  },\n  isFunction: function isFunction(obj) {\n    return obj instanceof Function;\n  }\n};\n\nvar INTERPRETATIONS = [\n{\n  litmus: Common.isString,\n  conversions: {\n    THREE_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    SIX_CHAR_HEX: {\n      read: function read(original) {\n        var test = original.match(/^#([A-F0-9]{6})$/i);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'HEX',\n          hex: parseInt('0x' + test[1].toString(), 0)\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGB: {\n      read: function read(original) {\n        var test = original.match(/^rgb\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3])\n        };\n      },\n      write: colorToString\n    },\n    CSS_RGBA: {\n      read: function read(original) {\n        var test = original.match(/^rgba\\(\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*,\\s*(\\S+)\\s*\\)/);\n        if (test === null) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: parseFloat(test[1]),\n          g: parseFloat(test[2]),\n          b: parseFloat(test[3]),\n          a: parseFloat(test[4])\n        };\n      },\n      write: colorToString\n    }\n  }\n},\n{\n  litmus: Common.isNumber,\n  conversions: {\n    HEX: {\n      read: function read(original) {\n        return {\n          space: 'HEX',\n          hex: original,\n          conversionName: 'HEX'\n        };\n      },\n      write: function write(color) {\n        return color.hex;\n      }\n    }\n  }\n},\n{\n  litmus: Common.isArray,\n  conversions: {\n    RGB_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 3) {\n          return false;\n        }\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b];\n      }\n    },\n    RGBA_ARRAY: {\n      read: function read(original) {\n        if (original.length !== 4) return false;\n        return {\n          space: 'RGB',\n          r: original[0],\n          g: original[1],\n          b: original[2],\n          a: original[3]\n        };\n      },\n      write: function write(color) {\n        return [color.r, color.g, color.b, color.a];\n      }\n    }\n  }\n},\n{\n  litmus: Common.isObject,\n  conversions: {\n    RGBA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b,\n          a: color.a\n        };\n      }\n    },\n    RGB_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {\n          return {\n            space: 'RGB',\n            r: original.r,\n            g: original.g,\n            b: original.b\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          r: color.r,\n          g: color.g,\n          b: color.b\n        };\n      }\n    },\n    HSVA_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v,\n            a: original.a\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v,\n          a: color.a\n        };\n      }\n    },\n    HSV_OBJ: {\n      read: function read(original) {\n        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {\n          return {\n            space: 'HSV',\n            h: original.h,\n            s: original.s,\n            v: original.v\n          };\n        }\n        return false;\n      },\n      write: function write(color) {\n        return {\n          h: color.h,\n          s: color.s,\n          v: color.v\n        };\n      }\n    }\n  }\n}];\nvar result = void 0;\nvar toReturn = void 0;\nvar interpret = function interpret() {\n  toReturn = false;\n  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];\n  Common.each(INTERPRETATIONS, function (family) {\n    if (family.litmus(original)) {\n      Common.each(family.conversions, function (conversion, conversionName) {\n        result = conversion.read(original);\n        if (toReturn === false && result !== false) {\n          toReturn = result;\n          result.conversionName = conversionName;\n          result.conversion = conversion;\n          return Common.BREAK;\n        }\n      });\n      return Common.BREAK;\n    }\n  });\n  return toReturn;\n};\n\nvar tmpComponent = void 0;\nvar ColorMath = {\n  hsv_to_rgb: function hsv_to_rgb(h, s, v) {\n    var hi = Math.floor(h / 60) % 6;\n    var f = h / 60 - Math.floor(h / 60);\n    var p = v * (1.0 - s);\n    var q = v * (1.0 - f * s);\n    var t = v * (1.0 - (1.0 - f) * s);\n    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];\n    return {\n      r: c[0] * 255,\n      g: c[1] * 255,\n      b: c[2] * 255\n    };\n  },\n  rgb_to_hsv: function rgb_to_hsv(r, g, b) {\n    var min = Math.min(r, g, b);\n    var max = Math.max(r, g, b);\n    var delta = max - min;\n    var h = void 0;\n    var s = void 0;\n    if (max !== 0) {\n      s = delta / max;\n    } else {\n      return {\n        h: NaN,\n        s: 0,\n        v: 0\n      };\n    }\n    if (r === max) {\n      h = (g - b) / delta;\n    } else if (g === max) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n    h /= 6;\n    if (h < 0) {\n      h += 1;\n    }\n    return {\n      h: h * 360,\n      s: s,\n      v: max / 255\n    };\n  },\n  rgb_to_hex: function rgb_to_hex(r, g, b) {\n    var hex = this.hex_with_component(0, 2, r);\n    hex = this.hex_with_component(hex, 1, g);\n    hex = this.hex_with_component(hex, 0, b);\n    return hex;\n  },\n  component_from_hex: function component_from_hex(hex, componentIndex) {\n    return hex >> componentIndex * 8 & 0xFF;\n  },\n  hex_with_component: function hex_with_component(hex, componentIndex, value) {\n    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);\n  }\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Color = function () {\n  function Color() {\n    classCallCheck(this, Color);\n    this.__state = interpret.apply(this, arguments);\n    if (this.__state === false) {\n      throw new Error('Failed to interpret color arguments');\n    }\n    this.__state.a = this.__state.a || 1;\n  }\n  createClass(Color, [{\n    key: 'toString',\n    value: function toString() {\n      return colorToString(this);\n    }\n  }, {\n    key: 'toHexString',\n    value: function toHexString() {\n      return colorToString(this, true);\n    }\n  }, {\n    key: 'toOriginal',\n    value: function toOriginal() {\n      return this.__state.conversion.write(this);\n    }\n  }]);\n  return Color;\n}();\nfunction defineRGBComponent(target, component, componentHexIndex) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'RGB') {\n        return this.__state[component];\n      }\n      Color.recalculateRGB(this, component, componentHexIndex);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'RGB') {\n        Color.recalculateRGB(this, component, componentHexIndex);\n        this.__state.space = 'RGB';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nfunction defineHSVComponent(target, component) {\n  Object.defineProperty(target, component, {\n    get: function get$$1() {\n      if (this.__state.space === 'HSV') {\n        return this.__state[component];\n      }\n      Color.recalculateHSV(this);\n      return this.__state[component];\n    },\n    set: function set$$1(v) {\n      if (this.__state.space !== 'HSV') {\n        Color.recalculateHSV(this);\n        this.__state.space = 'HSV';\n      }\n      this.__state[component] = v;\n    }\n  });\n}\nColor.recalculateRGB = function (color, component, componentHexIndex) {\n  if (color.__state.space === 'HEX') {\n    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);\n  } else if (color.__state.space === 'HSV') {\n    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));\n  } else {\n    throw new Error('Corrupted color state');\n  }\n};\nColor.recalculateHSV = function (color) {\n  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);\n  Common.extend(color.__state, {\n    s: result.s,\n    v: result.v\n  });\n  if (!Common.isNaN(result.h)) {\n    color.__state.h = result.h;\n  } else if (Common.isUndefined(color.__state.h)) {\n    color.__state.h = 0;\n  }\n};\nColor.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];\ndefineRGBComponent(Color.prototype, 'r', 2);\ndefineRGBComponent(Color.prototype, 'g', 1);\ndefineRGBComponent(Color.prototype, 'b', 0);\ndefineHSVComponent(Color.prototype, 'h');\ndefineHSVComponent(Color.prototype, 's');\ndefineHSVComponent(Color.prototype, 'v');\nObject.defineProperty(Color.prototype, 'a', {\n  get: function get$$1() {\n    return this.__state.a;\n  },\n  set: function set$$1(v) {\n    this.__state.a = v;\n  }\n});\nObject.defineProperty(Color.prototype, 'hex', {\n  get: function get$$1() {\n    if (this.__state.space !== 'HEX') {\n      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);\n      this.__state.space = 'HEX';\n    }\n    return this.__state.hex;\n  },\n  set: function set$$1(v) {\n    this.__state.space = 'HEX';\n    this.__state.hex = v;\n  }\n});\n\nvar Controller = function () {\n  function Controller(object, property) {\n    classCallCheck(this, Controller);\n    this.initialValue = object[property];\n    this.domElement = document.createElement('div');\n    this.object = object;\n    this.property = property;\n    this.__onChange = undefined;\n    this.__onFinishChange = undefined;\n  }\n  createClass(Controller, [{\n    key: 'onChange',\n    value: function onChange(fnc) {\n      this.__onChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'onFinishChange',\n    value: function onFinishChange(fnc) {\n      this.__onFinishChange = fnc;\n      return this;\n    }\n  }, {\n    key: 'setValue',\n    value: function setValue(newValue) {\n      this.object[this.property] = newValue;\n      if (this.__onChange) {\n        this.__onChange.call(this, newValue);\n      }\n      this.updateDisplay();\n      return this;\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.object[this.property];\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      return this;\n    }\n  }, {\n    key: 'isModified',\n    value: function isModified() {\n      return this.initialValue !== this.getValue();\n    }\n  }]);\n  return Controller;\n}();\n\nvar EVENT_MAP = {\n  HTMLEvents: ['change'],\n  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],\n  KeyboardEvents: ['keydown']\n};\nvar EVENT_MAP_INV = {};\nCommon.each(EVENT_MAP, function (v, k) {\n  Common.each(v, function (e) {\n    EVENT_MAP_INV[e] = k;\n  });\n});\nvar CSS_VALUE_PIXELS = /(\\d+(\\.\\d+)?)px/;\nfunction cssValueToPixels(val) {\n  if (val === '0' || Common.isUndefined(val)) {\n    return 0;\n  }\n  var match = val.match(CSS_VALUE_PIXELS);\n  if (!Common.isNull(match)) {\n    return parseFloat(match[1]);\n  }\n  return 0;\n}\nvar dom = {\n  makeSelectable: function makeSelectable(elem, selectable) {\n    if (elem === undefined || elem.style === undefined) return;\n    elem.onselectstart = selectable ? function () {\n      return false;\n    } : function () {};\n    elem.style.MozUserSelect = selectable ? 'auto' : 'none';\n    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';\n    elem.unselectable = selectable ? 'on' : 'off';\n  },\n  makeFullscreen: function makeFullscreen(elem, hor, vert) {\n    var vertical = vert;\n    var horizontal = hor;\n    if (Common.isUndefined(horizontal)) {\n      horizontal = true;\n    }\n    if (Common.isUndefined(vertical)) {\n      vertical = true;\n    }\n    elem.style.position = 'absolute';\n    if (horizontal) {\n      elem.style.left = 0;\n      elem.style.right = 0;\n    }\n    if (vertical) {\n      elem.style.top = 0;\n      elem.style.bottom = 0;\n    }\n  },\n  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {\n    var params = pars || {};\n    var className = EVENT_MAP_INV[eventType];\n    if (!className) {\n      throw new Error('Event type ' + eventType + ' not supported.');\n    }\n    var evt = document.createEvent(className);\n    switch (className) {\n      case 'MouseEvents':\n        {\n          var clientX = params.x || params.clientX || 0;\n          var clientY = params.y || params.clientY || 0;\n          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,\n          0,\n          clientX,\n          clientY,\n          false, false, false, false, 0, null);\n          break;\n        }\n      case 'KeyboardEvents':\n        {\n          var init = evt.initKeyboardEvent || evt.initKeyEvent;\n          Common.defaults(params, {\n            cancelable: true,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            keyCode: undefined,\n            charCode: undefined\n          });\n          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);\n          break;\n        }\n      default:\n        {\n          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);\n          break;\n        }\n    }\n    Common.defaults(evt, aux);\n    elem.dispatchEvent(evt);\n  },\n  bind: function bind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.addEventListener) {\n      elem.addEventListener(event, func, bool);\n    } else if (elem.attachEvent) {\n      elem.attachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  unbind: function unbind(elem, event, func, newBool) {\n    var bool = newBool || false;\n    if (elem.removeEventListener) {\n      elem.removeEventListener(event, func, bool);\n    } else if (elem.detachEvent) {\n      elem.detachEvent('on' + event, func);\n    }\n    return dom;\n  },\n  addClass: function addClass(elem, className) {\n    if (elem.className === undefined) {\n      elem.className = className;\n    } else if (elem.className !== className) {\n      var classes = elem.className.split(/ +/);\n      if (classes.indexOf(className) === -1) {\n        classes.push(className);\n        elem.className = classes.join(' ').replace(/^\\s+/, '').replace(/\\s+$/, '');\n      }\n    }\n    return dom;\n  },\n  removeClass: function removeClass(elem, className) {\n    if (className) {\n      if (elem.className === className) {\n        elem.removeAttribute('class');\n      } else {\n        var classes = elem.className.split(/ +/);\n        var index = classes.indexOf(className);\n        if (index !== -1) {\n          classes.splice(index, 1);\n          elem.className = classes.join(' ');\n        }\n      }\n    } else {\n      elem.className = undefined;\n    }\n    return dom;\n  },\n  hasClass: function hasClass(elem, className) {\n    return new RegExp('(?:^|\\\\s+)' + className + '(?:\\\\s+|$)').test(elem.className) || false;\n  },\n  getWidth: function getWidth(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);\n  },\n  getHeight: function getHeight(elem) {\n    var style = getComputedStyle(elem);\n    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);\n  },\n  getOffset: function getOffset(el) {\n    var elem = el;\n    var offset = { left: 0, top: 0 };\n    if (elem.offsetParent) {\n      do {\n        offset.left += elem.offsetLeft;\n        offset.top += elem.offsetTop;\n        elem = elem.offsetParent;\n      } while (elem);\n    }\n    return offset;\n  },\n  isActive: function isActive(elem) {\n    return elem === document.activeElement && (elem.type || elem.href);\n  }\n};\n\nvar BooleanController = function (_Controller) {\n  inherits(BooleanController, _Controller);\n  function BooleanController(object, property) {\n    classCallCheck(this, BooleanController);\n    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__prev = _this2.getValue();\n    _this2.__checkbox = document.createElement('input');\n    _this2.__checkbox.setAttribute('type', 'checkbox');\n    function onChange() {\n      _this.setValue(!_this.__prev);\n    }\n    dom.bind(_this2.__checkbox, 'change', onChange, false);\n    _this2.domElement.appendChild(_this2.__checkbox);\n    _this2.updateDisplay();\n    return _this2;\n  }\n  createClass(BooleanController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      this.__prev = this.getValue();\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (this.getValue() === true) {\n        this.__checkbox.setAttribute('checked', 'checked');\n        this.__checkbox.checked = true;\n        this.__prev = true;\n      } else {\n        this.__checkbox.checked = false;\n        this.__prev = false;\n      }\n      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return BooleanController;\n}(Controller);\n\nvar OptionController = function (_Controller) {\n  inherits(OptionController, _Controller);\n  function OptionController(object, property, opts) {\n    classCallCheck(this, OptionController);\n    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));\n    var options = opts;\n    var _this = _this2;\n    _this2.__select = document.createElement('select');\n    if (Common.isArray(options)) {\n      var map = {};\n      Common.each(options, function (element) {\n        map[element] = element;\n      });\n      options = map;\n    }\n    Common.each(options, function (value, key) {\n      var opt = document.createElement('option');\n      opt.innerHTML = key;\n      opt.setAttribute('value', value);\n      _this.__select.appendChild(opt);\n    });\n    _this2.updateDisplay();\n    dom.bind(_this2.__select, 'change', function () {\n      var desiredValue = this.options[this.selectedIndex].value;\n      _this.setValue(desiredValue);\n    });\n    _this2.domElement.appendChild(_this2.__select);\n    return _this2;\n  }\n  createClass(OptionController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n      return toReturn;\n    }\n  }, {\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (dom.isActive(this.__select)) return this;\n      this.__select.value = this.getValue();\n      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return OptionController;\n}(Controller);\n\nvar StringController = function (_Controller) {\n  inherits(StringController, _Controller);\n  function StringController(object, property) {\n    classCallCheck(this, StringController);\n    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));\n    var _this = _this2;\n    function onChange() {\n      _this.setValue(_this.__input.value);\n    }\n    function onBlur() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'keyup', onChange);\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        this.blur();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(StringController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      if (!dom.isActive(this.__input)) {\n        this.__input.value = this.getValue();\n      }\n      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return StringController;\n}(Controller);\n\nfunction numDecimals(x) {\n  var _x = x.toString();\n  if (_x.indexOf('.') > -1) {\n    return _x.length - _x.indexOf('.') - 1;\n  }\n  return 0;\n}\nvar NumberController = function (_Controller) {\n  inherits(NumberController, _Controller);\n  function NumberController(object, property, params) {\n    classCallCheck(this, NumberController);\n    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));\n    var _params = params || {};\n    _this.__min = _params.min;\n    _this.__max = _params.max;\n    _this.__step = _params.step;\n    if (Common.isUndefined(_this.__step)) {\n      if (_this.initialValue === 0) {\n        _this.__impliedStep = 1;\n      } else {\n        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;\n      }\n    } else {\n      _this.__impliedStep = _this.__step;\n    }\n    _this.__precision = numDecimals(_this.__impliedStep);\n    return _this;\n  }\n  createClass(NumberController, [{\n    key: 'setValue',\n    value: function setValue(v) {\n      var _v = v;\n      if (this.__min !== undefined && _v < this.__min) {\n        _v = this.__min;\n      } else if (this.__max !== undefined && _v > this.__max) {\n        _v = this.__max;\n      }\n      if (this.__step !== undefined && _v % this.__step !== 0) {\n        _v = Math.round(_v / this.__step) * this.__step;\n      }\n      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);\n    }\n  }, {\n    key: 'min',\n    value: function min(minValue) {\n      this.__min = minValue;\n      return this;\n    }\n  }, {\n    key: 'max',\n    value: function max(maxValue) {\n      this.__max = maxValue;\n      return this;\n    }\n  }, {\n    key: 'step',\n    value: function step(stepValue) {\n      this.__step = stepValue;\n      this.__impliedStep = stepValue;\n      this.__precision = numDecimals(stepValue);\n      return this;\n    }\n  }]);\n  return NumberController;\n}(Controller);\n\nfunction roundToDecimal(value, decimals) {\n  var tenTo = Math.pow(10, decimals);\n  return Math.round(value * tenTo) / tenTo;\n}\nvar NumberControllerBox = function (_NumberController) {\n  inherits(NumberControllerBox, _NumberController);\n  function NumberControllerBox(object, property, params) {\n    classCallCheck(this, NumberControllerBox);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));\n    _this2.__truncationSuspended = false;\n    var _this = _this2;\n    var prevY = void 0;\n    function onChange() {\n      var attempted = parseFloat(_this.__input.value);\n      if (!Common.isNaN(attempted)) {\n        _this.setValue(attempted);\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onBlur() {\n      onFinish();\n    }\n    function onMouseDrag(e) {\n      var diff = prevY - e.clientY;\n      _this.setValue(_this.getValue() + diff * _this.__impliedStep);\n      prevY = e.clientY;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      onFinish();\n    }\n    function onMouseDown(e) {\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      prevY = e.clientY;\n    }\n    _this2.__input = document.createElement('input');\n    _this2.__input.setAttribute('type', 'text');\n    dom.bind(_this2.__input, 'change', onChange);\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__input, 'mousedown', onMouseDown);\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        _this.__truncationSuspended = true;\n        this.blur();\n        _this.__truncationSuspended = false;\n        onFinish();\n      }\n    });\n    _this2.updateDisplay();\n    _this2.domElement.appendChild(_this2.__input);\n    return _this2;\n  }\n  createClass(NumberControllerBox, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);\n      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerBox;\n}(NumberController);\n\nfunction map(v, i1, i2, o1, o2) {\n  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));\n}\nvar NumberControllerSlider = function (_NumberController) {\n  inherits(NumberControllerSlider, _NumberController);\n  function NumberControllerSlider(object, property, min, max, step) {\n    classCallCheck(this, NumberControllerSlider);\n    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));\n    var _this = _this2;\n    _this2.__background = document.createElement('div');\n    _this2.__foreground = document.createElement('div');\n    dom.bind(_this2.__background, 'mousedown', onMouseDown);\n    dom.bind(_this2.__background, 'touchstart', onTouchStart);\n    dom.addClass(_this2.__background, 'slider');\n    dom.addClass(_this2.__foreground, 'slider-fg');\n    function onMouseDown(e) {\n      document.activeElement.blur();\n      dom.bind(window, 'mousemove', onMouseDrag);\n      dom.bind(window, 'mouseup', onMouseUp);\n      onMouseDrag(e);\n    }\n    function onMouseDrag(e) {\n      e.preventDefault();\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n      return false;\n    }\n    function onMouseUp() {\n      dom.unbind(window, 'mousemove', onMouseDrag);\n      dom.unbind(window, 'mouseup', onMouseUp);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    function onTouchStart(e) {\n      if (e.touches.length !== 1) {\n        return;\n      }\n      dom.bind(window, 'touchmove', onTouchMove);\n      dom.bind(window, 'touchend', onTouchEnd);\n      onTouchMove(e);\n    }\n    function onTouchMove(e) {\n      var clientX = e.touches[0].clientX;\n      var bgRect = _this.__background.getBoundingClientRect();\n      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));\n    }\n    function onTouchEnd() {\n      dom.unbind(window, 'touchmove', onTouchMove);\n      dom.unbind(window, 'touchend', onTouchEnd);\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.getValue());\n      }\n    }\n    _this2.updateDisplay();\n    _this2.__background.appendChild(_this2.__foreground);\n    _this2.domElement.appendChild(_this2.__background);\n    return _this2;\n  }\n  createClass(NumberControllerSlider, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);\n      this.__foreground.style.width = pct * 100 + '%';\n      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);\n    }\n  }]);\n  return NumberControllerSlider;\n}(NumberController);\n\nvar FunctionController = function (_Controller) {\n  inherits(FunctionController, _Controller);\n  function FunctionController(object, property, text) {\n    classCallCheck(this, FunctionController);\n    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));\n    var _this = _this2;\n    _this2.__button = document.createElement('div');\n    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;\n    dom.bind(_this2.__button, 'click', function (e) {\n      e.preventDefault();\n      _this.fire();\n      return false;\n    });\n    dom.addClass(_this2.__button, 'button');\n    _this2.domElement.appendChild(_this2.__button);\n    return _this2;\n  }\n  createClass(FunctionController, [{\n    key: 'fire',\n    value: function fire() {\n      if (this.__onChange) {\n        this.__onChange.call(this);\n      }\n      this.getValue().call(this.object);\n      if (this.__onFinishChange) {\n        this.__onFinishChange.call(this, this.getValue());\n      }\n    }\n  }]);\n  return FunctionController;\n}(Controller);\n\nvar ColorController = function (_Controller) {\n  inherits(ColorController, _Controller);\n  function ColorController(object, property) {\n    classCallCheck(this, ColorController);\n    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));\n    _this2.__color = new Color(_this2.getValue());\n    _this2.__temp = new Color(0);\n    var _this = _this2;\n    _this2.domElement = document.createElement('div');\n    dom.makeSelectable(_this2.domElement, false);\n    _this2.__selector = document.createElement('div');\n    _this2.__selector.className = 'selector';\n    _this2.__saturation_field = document.createElement('div');\n    _this2.__saturation_field.className = 'saturation-field';\n    _this2.__field_knob = document.createElement('div');\n    _this2.__field_knob.className = 'field-knob';\n    _this2.__field_knob_border = '2px solid ';\n    _this2.__hue_knob = document.createElement('div');\n    _this2.__hue_knob.className = 'hue-knob';\n    _this2.__hue_field = document.createElement('div');\n    _this2.__hue_field.className = 'hue-field';\n    _this2.__input = document.createElement('input');\n    _this2.__input.type = 'text';\n    _this2.__input_textShadow = '0 1px 1px ';\n    dom.bind(_this2.__input, 'keydown', function (e) {\n      if (e.keyCode === 13) {\n        onBlur.call(this);\n      }\n    });\n    dom.bind(_this2.__input, 'blur', onBlur);\n    dom.bind(_this2.__selector, 'mousedown', function () {\n      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    dom.bind(_this2.__selector, 'touchstart', function () {\n      dom.addClass(this, 'drag').bind(window, 'touchend', function () {\n        dom.removeClass(_this.__selector, 'drag');\n      });\n    });\n    var valueField = document.createElement('div');\n    Common.extend(_this2.__selector.style, {\n      width: '122px',\n      height: '102px',\n      padding: '3px',\n      backgroundColor: '#222',\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'\n    });\n    Common.extend(_this2.__field_knob.style, {\n      position: 'absolute',\n      width: '12px',\n      height: '12px',\n      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),\n      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',\n      borderRadius: '12px',\n      zIndex: 1\n    });\n    Common.extend(_this2.__hue_knob.style, {\n      position: 'absolute',\n      width: '15px',\n      height: '2px',\n      borderRight: '4px solid #fff',\n      zIndex: 1\n    });\n    Common.extend(_this2.__saturation_field.style, {\n      width: '100px',\n      height: '100px',\n      border: '1px solid #555',\n      marginRight: '3px',\n      display: 'inline-block',\n      cursor: 'pointer'\n    });\n    Common.extend(valueField.style, {\n      width: '100%',\n      height: '100%',\n      background: 'none'\n    });\n    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');\n    Common.extend(_this2.__hue_field.style, {\n      width: '15px',\n      height: '100px',\n      border: '1px solid #555',\n      cursor: 'ns-resize',\n      position: 'absolute',\n      top: '3px',\n      right: '3px'\n    });\n    hueGradient(_this2.__hue_field);\n    Common.extend(_this2.__input.style, {\n      outline: 'none',\n      textAlign: 'center',\n      color: '#fff',\n      border: 0,\n      fontWeight: 'bold',\n      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'\n    });\n    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);\n    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);\n    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);\n    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);\n    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);\n    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);\n    function fieldDown(e) {\n      setSV(e);\n      dom.bind(window, 'mousemove', setSV);\n      dom.bind(window, 'touchmove', setSV);\n      dom.bind(window, 'mouseup', fieldUpSV);\n      dom.bind(window, 'touchend', fieldUpSV);\n    }\n    function fieldDownH(e) {\n      setH(e);\n      dom.bind(window, 'mousemove', setH);\n      dom.bind(window, 'touchmove', setH);\n      dom.bind(window, 'mouseup', fieldUpH);\n      dom.bind(window, 'touchend', fieldUpH);\n    }\n    function fieldUpSV() {\n      dom.unbind(window, 'mousemove', setSV);\n      dom.unbind(window, 'touchmove', setSV);\n      dom.unbind(window, 'mouseup', fieldUpSV);\n      dom.unbind(window, 'touchend', fieldUpSV);\n      onFinish();\n    }\n    function fieldUpH() {\n      dom.unbind(window, 'mousemove', setH);\n      dom.unbind(window, 'touchmove', setH);\n      dom.unbind(window, 'mouseup', fieldUpH);\n      dom.unbind(window, 'touchend', fieldUpH);\n      onFinish();\n    }\n    function onBlur() {\n      var i = interpret(this.value);\n      if (i !== false) {\n        _this.__color.__state = i;\n        _this.setValue(_this.__color.toOriginal());\n      } else {\n        this.value = _this.__color.toString();\n      }\n    }\n    function onFinish() {\n      if (_this.__onFinishChange) {\n        _this.__onFinishChange.call(_this, _this.__color.toOriginal());\n      }\n    }\n    _this2.__saturation_field.appendChild(valueField);\n    _this2.__selector.appendChild(_this2.__field_knob);\n    _this2.__selector.appendChild(_this2.__saturation_field);\n    _this2.__selector.appendChild(_this2.__hue_field);\n    _this2.__hue_field.appendChild(_this2.__hue_knob);\n    _this2.domElement.appendChild(_this2.__input);\n    _this2.domElement.appendChild(_this2.__selector);\n    _this2.updateDisplay();\n    function setSV(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__saturation_field.getBoundingClientRect();\n      var _ref = e.touches && e.touches[0] || e,\n          clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);\n      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (v > 1) {\n        v = 1;\n      } else if (v < 0) {\n        v = 0;\n      }\n      if (s > 1) {\n        s = 1;\n      } else if (s < 0) {\n        s = 0;\n      }\n      _this.__color.v = v;\n      _this.__color.s = s;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    function setH(e) {\n      if (e.type.indexOf('touch') === -1) {\n        e.preventDefault();\n      }\n      var fieldRect = _this.__hue_field.getBoundingClientRect();\n      var _ref2 = e.touches && e.touches[0] || e,\n          clientY = _ref2.clientY;\n      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);\n      if (h > 1) {\n        h = 1;\n      } else if (h < 0) {\n        h = 0;\n      }\n      _this.__color.h = h * 360;\n      _this.setValue(_this.__color.toOriginal());\n      return false;\n    }\n    return _this2;\n  }\n  createClass(ColorController, [{\n    key: 'updateDisplay',\n    value: function updateDisplay() {\n      var i = interpret(this.getValue());\n      if (i !== false) {\n        var mismatch = false;\n        Common.each(Color.COMPONENTS, function (component) {\n          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {\n            mismatch = true;\n            return {};\n          }\n        }, this);\n        if (mismatch) {\n          Common.extend(this.__color.__state, i);\n        }\n      }\n      Common.extend(this.__temp.__state, this.__color.__state);\n      this.__temp.a = 1;\n      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;\n      var _flip = 255 - flip;\n      Common.extend(this.__field_knob.style, {\n        marginLeft: 100 * this.__color.s - 7 + 'px',\n        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',\n        backgroundColor: this.__temp.toHexString(),\n        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'\n      });\n      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';\n      this.__temp.s = 1;\n      this.__temp.v = 1;\n      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());\n      this.__input.value = this.__color.toString();\n      Common.extend(this.__input.style, {\n        backgroundColor: this.__color.toHexString(),\n        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',\n        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'\n      });\n    }\n  }]);\n  return ColorController;\n}(Controller);\nvar vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];\nfunction linearGradient(elem, x, a, b) {\n  elem.style.background = '';\n  Common.each(vendors, function (vendor) {\n    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';\n  });\n}\nfunction hueGradient(elem) {\n  elem.style.background = '';\n  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';\n  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';\n}\n\nvar css = {\n  load: function load(url, indoc) {\n    var doc = indoc || document;\n    var link = doc.createElement('link');\n    link.type = 'text/css';\n    link.rel = 'stylesheet';\n    link.href = url;\n    doc.getElementsByTagName('head')[0].appendChild(link);\n  },\n  inject: function inject(cssContent, indoc) {\n    var doc = indoc || document;\n    var injected = document.createElement('style');\n    injected.type = 'text/css';\n    injected.innerHTML = cssContent;\n    var head = doc.getElementsByTagName('head')[0];\n    try {\n      head.appendChild(injected);\n    } catch (e) {\n    }\n  }\n};\n\nvar saveDialogContents = \"<div id=\\\"dg-save\\\" class=\\\"dg dialogue\\\">\\n\\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\\n\\n  <textarea id=\\\"dg-new-constructor\\\"></textarea>\\n\\n  <div id=\\\"dg-save-locally\\\">\\n\\n    <input id=\\\"dg-local-storage\\\" type=\\\"checkbox\\\"/> Automatically save\\n    values to <code>localStorage</code> on exit.\\n\\n    <div id=\\\"dg-local-explain\\\">The values saved to <code>localStorage</code> will\\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\\n      easier to work incrementally, but <code>localStorage</code> is fragile,\\n      and your friends may not see the same values you do.\\n\\n    </div>\\n\\n  </div>\\n\\n</div>\";\n\nvar ControllerFactory = function ControllerFactory(object, property) {\n  var initialValue = object[property];\n  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {\n    return new OptionController(object, property, arguments[2]);\n  }\n  if (Common.isNumber(initialValue)) {\n    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {\n      if (Common.isNumber(arguments[4])) {\n        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);\n      }\n      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);\n    }\n    if (Common.isNumber(arguments[4])) {\n      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });\n    }\n    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });\n  }\n  if (Common.isString(initialValue)) {\n    return new StringController(object, property);\n  }\n  if (Common.isFunction(initialValue)) {\n    return new FunctionController(object, property, '');\n  }\n  if (Common.isBoolean(initialValue)) {\n    return new BooleanController(object, property);\n  }\n  return null;\n};\n\nfunction requestAnimationFrame(callback) {\n  setTimeout(callback, 1000 / 60);\n}\nvar requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;\n\nvar CenteredDiv = function () {\n  function CenteredDiv() {\n    classCallCheck(this, CenteredDiv);\n    this.backgroundElement = document.createElement('div');\n    Common.extend(this.backgroundElement.style, {\n      backgroundColor: 'rgba(0,0,0,0.8)',\n      top: 0,\n      left: 0,\n      display: 'none',\n      zIndex: '1000',\n      opacity: 0,\n      WebkitTransition: 'opacity 0.2s linear',\n      transition: 'opacity 0.2s linear'\n    });\n    dom.makeFullscreen(this.backgroundElement);\n    this.backgroundElement.style.position = 'fixed';\n    this.domElement = document.createElement('div');\n    Common.extend(this.domElement.style, {\n      position: 'fixed',\n      display: 'none',\n      zIndex: '1001',\n      opacity: 0,\n      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',\n      transition: 'transform 0.2s ease-out, opacity 0.2s linear'\n    });\n    document.body.appendChild(this.backgroundElement);\n    document.body.appendChild(this.domElement);\n    var _this = this;\n    dom.bind(this.backgroundElement, 'click', function () {\n      _this.hide();\n    });\n  }\n  createClass(CenteredDiv, [{\n    key: 'show',\n    value: function show() {\n      var _this = this;\n      this.backgroundElement.style.display = 'block';\n      this.domElement.style.display = 'block';\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n      this.layout();\n      Common.defer(function () {\n        _this.backgroundElement.style.opacity = 1;\n        _this.domElement.style.opacity = 1;\n        _this.domElement.style.webkitTransform = 'scale(1)';\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      var _this = this;\n      var hide = function hide() {\n        _this.domElement.style.display = 'none';\n        _this.backgroundElement.style.display = 'none';\n        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);\n        dom.unbind(_this.domElement, 'transitionend', hide);\n        dom.unbind(_this.domElement, 'oTransitionEnd', hide);\n      };\n      dom.bind(this.domElement, 'webkitTransitionEnd', hide);\n      dom.bind(this.domElement, 'transitionend', hide);\n      dom.bind(this.domElement, 'oTransitionEnd', hide);\n      this.backgroundElement.style.opacity = 0;\n      this.domElement.style.opacity = 0;\n      this.domElement.style.webkitTransform = 'scale(1.1)';\n    }\n  }, {\n    key: 'layout',\n    value: function layout() {\n      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';\n      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';\n    }\n  }]);\n  return CenteredDiv;\n}();\n\nvar styleSheet = ___$insertStyle(\".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\\n\");\n\ncss.inject(styleSheet);\nvar CSS_NAMESPACE = 'dg';\nvar HIDE_KEY_CODE = 72;\nvar CLOSE_BUTTON_HEIGHT = 20;\nvar DEFAULT_DEFAULT_PRESET_NAME = 'Default';\nvar SUPPORTS_LOCAL_STORAGE = function () {\n  try {\n    return !!window.localStorage;\n  } catch (e) {\n    return false;\n  }\n}();\nvar SAVE_DIALOGUE = void 0;\nvar autoPlaceVirgin = true;\nvar autoPlaceContainer = void 0;\nvar hide = false;\nvar hideableGuis = [];\nvar GUI = function GUI(pars) {\n  var _this = this;\n  var params = pars || {};\n  this.domElement = document.createElement('div');\n  this.__ul = document.createElement('ul');\n  this.domElement.appendChild(this.__ul);\n  dom.addClass(this.domElement, CSS_NAMESPACE);\n  this.__folders = {};\n  this.__controllers = [];\n  this.__rememberedObjects = [];\n  this.__rememberedObjectIndecesToControllers = [];\n  this.__listening = [];\n  params = Common.defaults(params, {\n    closeOnTop: false,\n    autoPlace: true,\n    width: GUI.DEFAULT_WIDTH\n  });\n  params = Common.defaults(params, {\n    resizable: params.autoPlace,\n    hideable: params.autoPlace\n  });\n  if (!Common.isUndefined(params.load)) {\n    if (params.preset) {\n      params.load.preset = params.preset;\n    }\n  } else {\n    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };\n  }\n  if (Common.isUndefined(params.parent) && params.hideable) {\n    hideableGuis.push(this);\n  }\n  params.resizable = Common.isUndefined(params.parent) && params.resizable;\n  if (params.autoPlace && Common.isUndefined(params.scrollable)) {\n    params.scrollable = true;\n  }\n  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';\n  var saveToLocalStorage = void 0;\n  var titleRow = void 0;\n  Object.defineProperties(this,\n  {\n    parent: {\n      get: function get$$1() {\n        return params.parent;\n      }\n    },\n    scrollable: {\n      get: function get$$1() {\n        return params.scrollable;\n      }\n    },\n    autoPlace: {\n      get: function get$$1() {\n        return params.autoPlace;\n      }\n    },\n    closeOnTop: {\n      get: function get$$1() {\n        return params.closeOnTop;\n      }\n    },\n    preset: {\n      get: function get$$1() {\n        if (_this.parent) {\n          return _this.getRoot().preset;\n        }\n        return params.load.preset;\n      },\n      set: function set$$1(v) {\n        if (_this.parent) {\n          _this.getRoot().preset = v;\n        } else {\n          params.load.preset = v;\n        }\n        setPresetSelectIndex(this);\n        _this.revert();\n      }\n    },\n    width: {\n      get: function get$$1() {\n        return params.width;\n      },\n      set: function set$$1(v) {\n        params.width = v;\n        setWidth(_this, v);\n      }\n    },\n    name: {\n      get: function get$$1() {\n        return params.name;\n      },\n      set: function set$$1(v) {\n        params.name = v;\n        if (titleRow) {\n          titleRow.innerHTML = params.name;\n        }\n      }\n    },\n    closed: {\n      get: function get$$1() {\n        return params.closed;\n      },\n      set: function set$$1(v) {\n        params.closed = v;\n        if (params.closed) {\n          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);\n        } else {\n          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);\n        }\n        this.onResize();\n        if (_this.__closeButton) {\n          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;\n        }\n      }\n    },\n    load: {\n      get: function get$$1() {\n        return params.load;\n      }\n    },\n    useLocalStorage: {\n      get: function get$$1() {\n        return useLocalStorage;\n      },\n      set: function set$$1(bool) {\n        if (SUPPORTS_LOCAL_STORAGE) {\n          useLocalStorage = bool;\n          if (bool) {\n            dom.bind(window, 'unload', saveToLocalStorage);\n          } else {\n            dom.unbind(window, 'unload', saveToLocalStorage);\n          }\n          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);\n        }\n      }\n    }\n  });\n  if (Common.isUndefined(params.parent)) {\n    this.closed = params.closed || false;\n    dom.addClass(this.domElement, GUI.CLASS_MAIN);\n    dom.makeSelectable(this.domElement, false);\n    if (SUPPORTS_LOCAL_STORAGE) {\n      if (useLocalStorage) {\n        _this.useLocalStorage = true;\n        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));\n        if (savedGui) {\n          params.load = JSON.parse(savedGui);\n        }\n      }\n    }\n    this.__closeButton = document.createElement('div');\n    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;\n    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);\n    if (params.closeOnTop) {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);\n      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);\n    } else {\n      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);\n      this.domElement.appendChild(this.__closeButton);\n    }\n    dom.bind(this.__closeButton, 'click', function () {\n      _this.closed = !_this.closed;\n    });\n  } else {\n    if (params.closed === undefined) {\n      params.closed = true;\n    }\n    var titleRowName = document.createTextNode(params.name);\n    dom.addClass(titleRowName, 'controller-name');\n    titleRow = addRow(_this, titleRowName);\n    var onClickTitle = function onClickTitle(e) {\n      e.preventDefault();\n      _this.closed = !_this.closed;\n      return false;\n    };\n    dom.addClass(this.__ul, GUI.CLASS_CLOSED);\n    dom.addClass(titleRow, 'title');\n    dom.bind(titleRow, 'click', onClickTitle);\n    if (!params.closed) {\n      this.closed = false;\n    }\n  }\n  if (params.autoPlace) {\n    if (Common.isUndefined(params.parent)) {\n      if (autoPlaceVirgin) {\n        autoPlaceContainer = document.createElement('div');\n        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);\n        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);\n        document.body.appendChild(autoPlaceContainer);\n        autoPlaceVirgin = false;\n      }\n      autoPlaceContainer.appendChild(this.domElement);\n      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);\n    }\n    if (!this.parent) {\n      setWidth(_this, params.width);\n    }\n  }\n  this.__resizeHandler = function () {\n    _this.onResizeDebounced();\n  };\n  dom.bind(window, 'resize', this.__resizeHandler);\n  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);\n  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);\n  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);\n  this.onResize();\n  if (params.resizable) {\n    addResizeHandle(this);\n  }\n  saveToLocalStorage = function saveToLocalStorage() {\n    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {\n      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));\n    }\n  };\n  this.saveToLocalStorageIfPossible = saveToLocalStorage;\n  function resetWidth() {\n    var root = _this.getRoot();\n    root.width += 1;\n    Common.defer(function () {\n      root.width -= 1;\n    });\n  }\n  if (!params.parent) {\n    resetWidth();\n  }\n};\nGUI.toggleHide = function () {\n  hide = !hide;\n  Common.each(hideableGuis, function (gui) {\n    gui.domElement.style.display = hide ? 'none' : '';\n  });\n};\nGUI.CLASS_AUTO_PLACE = 'a';\nGUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';\nGUI.CLASS_MAIN = 'main';\nGUI.CLASS_CONTROLLER_ROW = 'cr';\nGUI.CLASS_TOO_TALL = 'taller-than-window';\nGUI.CLASS_CLOSED = 'closed';\nGUI.CLASS_CLOSE_BUTTON = 'close-button';\nGUI.CLASS_CLOSE_TOP = 'close-top';\nGUI.CLASS_CLOSE_BOTTOM = 'close-bottom';\nGUI.CLASS_DRAG = 'drag';\nGUI.DEFAULT_WIDTH = 245;\nGUI.TEXT_CLOSED = 'Close Controls';\nGUI.TEXT_OPEN = 'Open Controls';\nGUI._keydownHandler = function (e) {\n  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {\n    GUI.toggleHide();\n  }\n};\ndom.bind(window, 'keydown', GUI._keydownHandler, false);\nCommon.extend(GUI.prototype,\n{\n  add: function add(object, property) {\n    return _add(this, object, property, {\n      factoryArgs: Array.prototype.slice.call(arguments, 2)\n    });\n  },\n  addColor: function addColor(object, property) {\n    return _add(this, object, property, {\n      color: true\n    });\n  },\n  remove: function remove(controller) {\n    this.__ul.removeChild(controller.__li);\n    this.__controllers.splice(this.__controllers.indexOf(controller), 1);\n    var _this = this;\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  destroy: function destroy() {\n    if (this.parent) {\n      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');\n    }\n    if (this.autoPlace) {\n      autoPlaceContainer.removeChild(this.domElement);\n    }\n    var _this = this;\n    Common.each(this.__folders, function (subfolder) {\n      _this.removeFolder(subfolder);\n    });\n    dom.unbind(window, 'keydown', GUI._keydownHandler, false);\n    removeListeners(this);\n  },\n  addFolder: function addFolder(name) {\n    if (this.__folders[name] !== undefined) {\n      throw new Error('You already have a folder in this GUI by the' + ' name \"' + name + '\"');\n    }\n    var newGuiParams = { name: name, parent: this };\n    newGuiParams.autoPlace = this.autoPlace;\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[name]) {\n      newGuiParams.closed = this.load.folders[name].closed;\n      newGuiParams.load = this.load.folders[name];\n    }\n    var gui = new GUI(newGuiParams);\n    this.__folders[name] = gui;\n    var li = addRow(this, gui.domElement);\n    dom.addClass(li, 'folder');\n    return gui;\n  },\n  removeFolder: function removeFolder(folder) {\n    this.__ul.removeChild(folder.domElement.parentElement);\n    delete this.__folders[folder.name];\n    if (this.load &&\n    this.load.folders &&\n    this.load.folders[folder.name]) {\n      delete this.load.folders[folder.name];\n    }\n    removeListeners(folder);\n    var _this = this;\n    Common.each(folder.__folders, function (subfolder) {\n      folder.removeFolder(subfolder);\n    });\n    Common.defer(function () {\n      _this.onResize();\n    });\n  },\n  open: function open() {\n    this.closed = false;\n  },\n  close: function close() {\n    this.closed = true;\n  },\n  hide: function hide() {\n    this.domElement.style.display = 'none';\n  },\n  show: function show() {\n    this.domElement.style.display = '';\n  },\n  onResize: function onResize() {\n    var root = this.getRoot();\n    if (root.scrollable) {\n      var top = dom.getOffset(root.__ul).top;\n      var h = 0;\n      Common.each(root.__ul.childNodes, function (node) {\n        if (!(root.autoPlace && node === root.__save_row)) {\n          h += dom.getHeight(node);\n        }\n      });\n      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {\n        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';\n      } else {\n        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);\n        root.__ul.style.height = 'auto';\n      }\n    }\n    if (root.__resize_handle) {\n      Common.defer(function () {\n        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';\n      });\n    }\n    if (root.__closeButton) {\n      root.__closeButton.style.width = root.width + 'px';\n    }\n  },\n  onResizeDebounced: Common.debounce(function () {\n    this.onResize();\n  }, 50),\n  remember: function remember() {\n    if (Common.isUndefined(SAVE_DIALOGUE)) {\n      SAVE_DIALOGUE = new CenteredDiv();\n      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;\n    }\n    if (this.parent) {\n      throw new Error('You can only call remember on a top level GUI.');\n    }\n    var _this = this;\n    Common.each(Array.prototype.slice.call(arguments), function (object) {\n      if (_this.__rememberedObjects.length === 0) {\n        addSaveMenu(_this);\n      }\n      if (_this.__rememberedObjects.indexOf(object) === -1) {\n        _this.__rememberedObjects.push(object);\n      }\n    });\n    if (this.autoPlace) {\n      setWidth(this, this.width);\n    }\n  },\n  getRoot: function getRoot() {\n    var gui = this;\n    while (gui.parent) {\n      gui = gui.parent;\n    }\n    return gui;\n  },\n  getSaveObject: function getSaveObject() {\n    var toReturn = this.load;\n    toReturn.closed = this.closed;\n    if (this.__rememberedObjects.length > 0) {\n      toReturn.preset = this.preset;\n      if (!toReturn.remembered) {\n        toReturn.remembered = {};\n      }\n      toReturn.remembered[this.preset] = getCurrentPreset(this);\n    }\n    toReturn.folders = {};\n    Common.each(this.__folders, function (element, key) {\n      toReturn.folders[key] = element.getSaveObject();\n    });\n    return toReturn;\n  },\n  save: function save() {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n    }\n    this.load.remembered[this.preset] = getCurrentPreset(this);\n    markPresetModified(this, false);\n    this.saveToLocalStorageIfPossible();\n  },\n  saveAs: function saveAs(presetName) {\n    if (!this.load.remembered) {\n      this.load.remembered = {};\n      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);\n    }\n    this.load.remembered[presetName] = getCurrentPreset(this);\n    this.preset = presetName;\n    addPresetOption(this, presetName, true);\n    this.saveToLocalStorageIfPossible();\n  },\n  revert: function revert(gui) {\n    Common.each(this.__controllers, function (controller) {\n      if (!this.getRoot().load.remembered) {\n        controller.setValue(controller.initialValue);\n      } else {\n        recallSavedValue(gui || this.getRoot(), controller);\n      }\n      if (controller.__onFinishChange) {\n        controller.__onFinishChange.call(controller, controller.getValue());\n      }\n    }, this);\n    Common.each(this.__folders, function (folder) {\n      folder.revert(folder);\n    });\n    if (!gui) {\n      markPresetModified(this.getRoot(), false);\n    }\n  },\n  listen: function listen(controller) {\n    var init = this.__listening.length === 0;\n    this.__listening.push(controller);\n    if (init) {\n      updateDisplays(this.__listening);\n    }\n  },\n  updateDisplay: function updateDisplay() {\n    Common.each(this.__controllers, function (controller) {\n      controller.updateDisplay();\n    });\n    Common.each(this.__folders, function (folder) {\n      folder.updateDisplay();\n    });\n  }\n});\nfunction addRow(gui, newDom, liBefore) {\n  var li = document.createElement('li');\n  if (newDom) {\n    li.appendChild(newDom);\n  }\n  if (liBefore) {\n    gui.__ul.insertBefore(li, liBefore);\n  } else {\n    gui.__ul.appendChild(li);\n  }\n  gui.onResize();\n  return li;\n}\nfunction removeListeners(gui) {\n  dom.unbind(window, 'resize', gui.__resizeHandler);\n  if (gui.saveToLocalStorageIfPossible) {\n    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);\n  }\n}\nfunction markPresetModified(gui, modified) {\n  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];\n  if (modified) {\n    opt.innerHTML = opt.value + '*';\n  } else {\n    opt.innerHTML = opt.value;\n  }\n}\nfunction augmentController(gui, li, controller) {\n  controller.__li = li;\n  controller.__gui = gui;\n  Common.extend(controller, {\n    options: function options(_options) {\n      if (arguments.length > 1) {\n        var nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: nextSibling,\n          factoryArgs: [Common.toArray(arguments)]\n        });\n      }\n      if (Common.isArray(_options) || Common.isObject(_options)) {\n        var _nextSibling = controller.__li.nextElementSibling;\n        controller.remove();\n        return _add(gui, controller.object, controller.property, {\n          before: _nextSibling,\n          factoryArgs: [_options]\n        });\n      }\n    },\n    name: function name(_name) {\n      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;\n      return controller;\n    },\n    listen: function listen() {\n      controller.__gui.listen(controller);\n      return controller;\n    },\n    remove: function remove() {\n      controller.__gui.remove(controller);\n      return controller;\n    }\n  });\n  if (controller instanceof NumberControllerSlider) {\n    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });\n    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {\n      var pc = controller[method];\n      var pb = box[method];\n      controller[method] = box[method] = function () {\n        var args = Array.prototype.slice.call(arguments);\n        pb.apply(box, args);\n        return pc.apply(controller, args);\n      };\n    });\n    dom.addClass(li, 'has-slider');\n    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);\n  } else if (controller instanceof NumberControllerBox) {\n    var r = function r(returned) {\n      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {\n        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;\n        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;\n        controller.remove();\n        var newController = _add(gui, controller.object, controller.property, {\n          before: controller.__li.nextElementSibling,\n          factoryArgs: [controller.__min, controller.__max, controller.__step]\n        });\n        newController.name(oldName);\n        if (wasListening) newController.listen();\n        return newController;\n      }\n      return returned;\n    };\n    controller.min = Common.compose(r, controller.min);\n    controller.max = Common.compose(r, controller.max);\n  } else if (controller instanceof BooleanController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__checkbox, 'click');\n    });\n    dom.bind(controller.__checkbox, 'click', function (e) {\n      e.stopPropagation();\n    });\n  } else if (controller instanceof FunctionController) {\n    dom.bind(li, 'click', function () {\n      dom.fakeEvent(controller.__button, 'click');\n    });\n    dom.bind(li, 'mouseover', function () {\n      dom.addClass(controller.__button, 'hover');\n    });\n    dom.bind(li, 'mouseout', function () {\n      dom.removeClass(controller.__button, 'hover');\n    });\n  } else if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n    controller.updateDisplay = Common.compose(function (val) {\n      li.style.borderLeftColor = controller.__color.toString();\n      return val;\n    }, controller.updateDisplay);\n    controller.updateDisplay();\n  }\n  controller.setValue = Common.compose(function (val) {\n    if (gui.getRoot().__preset_select && controller.isModified()) {\n      markPresetModified(gui.getRoot(), true);\n    }\n    return val;\n  }, controller.setValue);\n}\nfunction recallSavedValue(gui, controller) {\n  var root = gui.getRoot();\n  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);\n  if (matchedIndex !== -1) {\n    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];\n    if (controllerMap === undefined) {\n      controllerMap = {};\n      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;\n    }\n    controllerMap[controller.property] = controller;\n    if (root.load && root.load.remembered) {\n      var presetMap = root.load.remembered;\n      var preset = void 0;\n      if (presetMap[gui.preset]) {\n        preset = presetMap[gui.preset];\n      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {\n        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];\n      } else {\n        return;\n      }\n      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {\n        var value = preset[matchedIndex][controller.property];\n        controller.initialValue = value;\n        controller.setValue(value);\n      }\n    }\n  }\n}\nfunction _add(gui, object, property, params) {\n  if (object[property] === undefined) {\n    throw new Error('Object \"' + object + '\" has no property \"' + property + '\"');\n  }\n  var controller = void 0;\n  if (params.color) {\n    controller = new ColorController(object, property);\n  } else {\n    var factoryArgs = [object, property].concat(params.factoryArgs);\n    controller = ControllerFactory.apply(gui, factoryArgs);\n  }\n  if (params.before instanceof Controller) {\n    params.before = params.before.__li;\n  }\n  recallSavedValue(gui, controller);\n  dom.addClass(controller.domElement, 'c');\n  var name = document.createElement('span');\n  dom.addClass(name, 'property-name');\n  name.innerHTML = controller.property;\n  var container = document.createElement('div');\n  container.appendChild(name);\n  container.appendChild(controller.domElement);\n  var li = addRow(gui, container, params.before);\n  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);\n  if (controller instanceof ColorController) {\n    dom.addClass(li, 'color');\n  } else {\n    dom.addClass(li, _typeof(controller.getValue()));\n  }\n  augmentController(gui, li, controller);\n  gui.__controllers.push(controller);\n  return controller;\n}\nfunction getLocalStorageHash(gui, key) {\n  return document.location.href + '.' + key;\n}\nfunction addPresetOption(gui, name, setSelected) {\n  var opt = document.createElement('option');\n  opt.innerHTML = name;\n  opt.value = name;\n  gui.__preset_select.appendChild(opt);\n  if (setSelected) {\n    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;\n  }\n}\nfunction showHideExplain(gui, explain) {\n  explain.style.display = gui.useLocalStorage ? 'block' : 'none';\n}\nfunction addSaveMenu(gui) {\n  var div = gui.__save_row = document.createElement('li');\n  dom.addClass(gui.domElement, 'has-save');\n  gui.__ul.insertBefore(div, gui.__ul.firstChild);\n  dom.addClass(div, 'save-row');\n  var gears = document.createElement('span');\n  gears.innerHTML = '&nbsp;';\n  dom.addClass(gears, 'button gears');\n  var button = document.createElement('span');\n  button.innerHTML = 'Save';\n  dom.addClass(button, 'button');\n  dom.addClass(button, 'save');\n  var button2 = document.createElement('span');\n  button2.innerHTML = 'New';\n  dom.addClass(button2, 'button');\n  dom.addClass(button2, 'save-as');\n  var button3 = document.createElement('span');\n  button3.innerHTML = 'Revert';\n  dom.addClass(button3, 'button');\n  dom.addClass(button3, 'revert');\n  var select = gui.__preset_select = document.createElement('select');\n  if (gui.load && gui.load.remembered) {\n    Common.each(gui.load.remembered, function (value, key) {\n      addPresetOption(gui, key, key === gui.preset);\n    });\n  } else {\n    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);\n  }\n  dom.bind(select, 'change', function () {\n    for (var index = 0; index < gui.__preset_select.length; index++) {\n      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;\n    }\n    gui.preset = this.value;\n  });\n  div.appendChild(select);\n  div.appendChild(gears);\n  div.appendChild(button);\n  div.appendChild(button2);\n  div.appendChild(button3);\n  if (SUPPORTS_LOCAL_STORAGE) {\n    var explain = document.getElementById('dg-local-explain');\n    var localStorageCheckBox = document.getElementById('dg-local-storage');\n    var saveLocally = document.getElementById('dg-save-locally');\n    saveLocally.style.display = 'block';\n    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {\n      localStorageCheckBox.setAttribute('checked', 'checked');\n    }\n    showHideExplain(gui, explain);\n    dom.bind(localStorageCheckBox, 'change', function () {\n      gui.useLocalStorage = !gui.useLocalStorage;\n      showHideExplain(gui, explain);\n    });\n  }\n  var newConstructorTextArea = document.getElementById('dg-new-constructor');\n  dom.bind(newConstructorTextArea, 'keydown', function (e) {\n    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {\n      SAVE_DIALOGUE.hide();\n    }\n  });\n  dom.bind(gears, 'click', function () {\n    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);\n    SAVE_DIALOGUE.show();\n    newConstructorTextArea.focus();\n    newConstructorTextArea.select();\n  });\n  dom.bind(button, 'click', function () {\n    gui.save();\n  });\n  dom.bind(button2, 'click', function () {\n    var presetName = prompt('Enter a new preset name.');\n    if (presetName) {\n      gui.saveAs(presetName);\n    }\n  });\n  dom.bind(button3, 'click', function () {\n    gui.revert();\n  });\n}\nfunction addResizeHandle(gui) {\n  var pmouseX = void 0;\n  gui.__resize_handle = document.createElement('div');\n  Common.extend(gui.__resize_handle.style, {\n    width: '6px',\n    marginLeft: '-3px',\n    height: '200px',\n    cursor: 'ew-resize',\n    position: 'absolute'\n  });\n  function drag(e) {\n    e.preventDefault();\n    gui.width += pmouseX - e.clientX;\n    gui.onResize();\n    pmouseX = e.clientX;\n    return false;\n  }\n  function dragStop() {\n    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.unbind(window, 'mousemove', drag);\n    dom.unbind(window, 'mouseup', dragStop);\n  }\n  function dragStart(e) {\n    e.preventDefault();\n    pmouseX = e.clientX;\n    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);\n    dom.bind(window, 'mousemove', drag);\n    dom.bind(window, 'mouseup', dragStop);\n    return false;\n  }\n  dom.bind(gui.__resize_handle, 'mousedown', dragStart);\n  dom.bind(gui.__closeButton, 'mousedown', dragStart);\n  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);\n}\nfunction setWidth(gui, w) {\n  gui.domElement.style.width = w + 'px';\n  if (gui.__save_row && gui.autoPlace) {\n    gui.__save_row.style.width = w + 'px';\n  }\n  if (gui.__closeButton) {\n    gui.__closeButton.style.width = w + 'px';\n  }\n}\nfunction getCurrentPreset(gui, useInitialValues) {\n  var toReturn = {};\n  Common.each(gui.__rememberedObjects, function (val, index) {\n    var savedValues = {};\n    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];\n    Common.each(controllerMap, function (controller, property) {\n      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();\n    });\n    toReturn[index] = savedValues;\n  });\n  return toReturn;\n}\nfunction setPresetSelectIndex(gui) {\n  for (var index = 0; index < gui.__preset_select.length; index++) {\n    if (gui.__preset_select[index].value === gui.preset) {\n      gui.__preset_select.selectedIndex = index;\n    }\n  }\n}\nfunction updateDisplays(controllerArray) {\n  if (controllerArray.length !== 0) {\n    requestAnimationFrame$1.call(window, function () {\n      updateDisplays(controllerArray);\n    });\n  }\n  Common.each(controllerArray, function (c) {\n    c.updateDisplay();\n  });\n}\n\nvar color = {\n  Color: Color,\n  math: ColorMath,\n  interpret: interpret\n};\nvar controllers = {\n  Controller: Controller,\n  BooleanController: BooleanController,\n  OptionController: OptionController,\n  StringController: StringController,\n  NumberController: NumberController,\n  NumberControllerBox: NumberControllerBox,\n  NumberControllerSlider: NumberControllerSlider,\n  FunctionController: FunctionController,\n  ColorController: ColorController\n};\nvar dom$1 = { dom: dom };\nvar gui = { GUI: GUI };\nvar GUI$1 = GUI;\nvar index = {\n  color: color,\n  controllers: controllers,\n  dom: dom$1,\n  gui: gui,\n  GUI: GUI$1\n};\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceMappingURL=dat.gui.module.js.map\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/dat.gui/build/dat.gui.module.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/identity.js":
/*!******************************************!*\
  !*** ./node_modules/gl-mat4/identity.js ***!
  \******************************************/
/***/ ((module) => {

eval("module.exports = identity;\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nfunction identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/identity.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/invert.js":
/*!****************************************!*\
  !*** ./node_modules/gl-mat4/invert.js ***!
  \****************************************/
/***/ ((module) => {

eval("module.exports = invert;\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nfunction invert(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/invert.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/lookAt.js":
/*!****************************************!*\
  !*** ./node_modules/gl-mat4/lookAt.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var identity = __webpack_require__(/*! ./identity */ \"./node_modules/gl-mat4/identity.js\");\n\nmodule.exports = lookAt;\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nfunction lookAt(out, eye, center, up) {\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,\n        eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2],\n        centerx = center[0],\n        centery = center[1],\n        centerz = center[2];\n\n    if (Math.abs(eyex - centerx) < 0.000001 &&\n        Math.abs(eyey - centery) < 0.000001 &&\n        Math.abs(eyez - centerz) < 0.000001) {\n        return identity(out);\n    }\n\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n\n    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    } else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    } else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/lookAt.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/perspective.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-mat4/perspective.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = perspective;\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nfunction perspective(out, fovy, aspect, near, far) {\n    var f = 1.0 / Math.tan(fovy / 2),\n        nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (2 * far * near) * nf;\n    out[15] = 0;\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/perspective.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/scale.js":
/*!***************************************!*\
  !*** ./node_modules/gl-mat4/scale.js ***!
  \***************************************/
/***/ ((module) => {

eval("module.exports = scale;\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nfunction scale(out, a, v) {\n    var x = v[0], y = v[1], z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/scale.js?");

/***/ }),

/***/ "./node_modules/gl-mat4/translate.js":
/*!*******************************************!*\
  !*** ./node_modules/gl-mat4/translate.js ***!
  \*******************************************/
/***/ ((module) => {

eval("module.exports = translate;\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nfunction translate(out, a, v) {\n    var x = v[0], y = v[1], z = v[2],\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n};\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-mat4/translate.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/add.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/add.js ***!
  \*************************************/
/***/ ((module) => {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/copy.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/copy.js ***!
  \**************************************/
/***/ ((module) => {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/epsilon.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/epsilon.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/equals.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/equals.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/normalize.js":
/*!*******************************************!*\
  !*** ./node_modules/gl-vec3/normalize.js ***!
  \*******************************************/
/***/ ((module) => {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateX.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateX.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateY.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateY.js ***!
  \*****************************************/
/***/ ((module) => {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/scaleAndAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-vec3/scaleAndAdd.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformMat4.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformMat4.js ***!
  \***********************************************/
/***/ ((module) => {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/inertial-turntable-camera/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/inertial-turntable-camera/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar transformMat4 = __webpack_require__(/*! gl-vec3/transformMat4 */ \"./node_modules/gl-vec3/transformMat4.js\");\nvar vec3RotateY = __webpack_require__(/*! gl-vec3/rotateY */ \"./node_modules/gl-vec3/rotateY.js\");\nvar vec3RotateX = __webpack_require__(/*! gl-vec3/rotateX */ \"./node_modules/gl-vec3/rotateX.js\");\nvar vec3Equals = __webpack_require__(/*! gl-vec3/equals */ \"./node_modules/gl-vec3/equals.js\");\nvar vec3Add = __webpack_require__(/*! gl-vec3/add */ \"./node_modules/gl-vec3/add.js\");\nvar vec3ScaleAndAdd = __webpack_require__(/*! gl-vec3/scaleAndAdd */ \"./node_modules/gl-vec3/scaleAndAdd.js\");\nvar vec3Copy = __webpack_require__(/*! gl-vec3/copy */ \"./node_modules/gl-vec3/copy.js\");\nvar vec3Normalize = __webpack_require__(/*! gl-vec3/normalize */ \"./node_modules/gl-vec3/normalize.js\");\nvar mat4Identity = __webpack_require__(/*! gl-mat4/identity */ \"./node_modules/gl-mat4/identity.js\");\nvar mat4Invert = __webpack_require__(/*! gl-mat4/invert */ \"./node_modules/gl-mat4/invert.js\");\nvar mat4Translate = __webpack_require__(/*! gl-mat4/translate */ \"./node_modules/gl-mat4/translate.js\");\nvar mat4Scale = __webpack_require__(/*! gl-mat4/scale */ \"./node_modules/gl-mat4/scale.js\");\nvar lookAt = __webpack_require__(/*! gl-mat4/lookAt */ \"./node_modules/gl-mat4/lookAt.js\");\nvar perspective = __webpack_require__(/*! gl-mat4/perspective */ \"./node_modules/gl-mat4/perspective.js\");\n\n// This is a quick and dirty way of avoiding the poles.\nvar MAX_PHI = Math.PI * 0.5 - 1e-4;\nvar MIN_PHI = -Math.PI * 0.5 + 1e-4;\n\nmodule.exports = function createCamera (opts) {\n  opts = opts || {};\n\n  // A proxy flag with which we track the dirty params so that it doesn't need\n  // an extra method to tell the camera that the scene *has been* rendered.\n  var willBeDirty = true;\n\n  var params = {\n    aspectRatio: opts.aspectRatio ? opts.aspectRatio : 1,\n\n    // Zoom about the cursor as opposed to the center of the scene\n    zoomAboutCursor: opts.zoomAboutCursor === undefined ? true : opts.zoomAboutCursor,\n\n    // Spherical coords!\n    distance: opts.distance === undefined ? 10 : opts.distance,\n    phi: opts.phi === undefined ? 0 : opts.phi,\n    theta: opts.theta === undefined ? 0 : opts.theta,\n\n    // Camera parameters\n    fovY: opts.fovY === undefined ? Math.PI / 4 : opts.fovY,\n    near: opts.near === undefined ? 0.1 : opts.near,\n    far: opts.far === undefined ? 100 : opts.far,\n\n    // Decay of inertia, in ms\n    panDecayTime: opts.panDecayTime || 100,\n    zoomDecayTime: opts.zoomDecayTime || 100,\n    rotationDecayTime: opts.rotationDecayTime || 100,\n\n    dirty: true,\n\n    up: opts.up || new Float32Array([0, 1, 0]),\n    center: opts.center || new Float32Array(3),\n    rotationCenter: opts.rotationCenter || opts.center && opts.center.slice() || new Float32Array(3),\n\n    // Current interactions, which can be set directly. If setting directly, changes\n    // will be additive to changes resulting from interactions.\n    zoom: 0,\n    panX: 0,\n    panY: 0,\n    panZ: 0,\n    pitch: 0,\n    yaw: 0,\n    dTheta: 0,\n    dPhi: 0,\n\n    // Mouse coordinates of the interaction. Note that we fudge things ever so slightly\n    // here and only store one mouse position per frame, so that we might actually\n    // apply multiple accumulated events per frame about the *slightly* incorrect point.\n    // In reality, I think this fudgeable.\n    mouseX: 0,\n    mouseY: 0,\n  };\n\n  var t0 = null;\n  var camera = {\n    tick: function (mergeState) {\n      // If we've accumulated interactions, then set them in the params directly.\n      // Alternatively, we could recompute the full params on every single interaction\n      // event, but that would result in maybe twice as many full matrix/view updates\n      // as could ever be rendered in browsers like Safari that dispatch multiple\n      // events per requestAnimationFrame.\n      if (accumulator.zoom) params.zoom = accumulator.zoom;\n      if (accumulator.dTheta) params.dTheta = accumulator.dTheta;\n      if (accumulator.dPhi) params.dPhi = accumulator.dPhi;\n      if (accumulator.panX) params.panX = accumulator.panX;\n      if (accumulator.panY) params.panY = accumulator.panY;\n      if (accumulator.panZ) params.panZ = accumulator.panZ;\n      if (accumulator.yaw) params.yaw = accumulator.yaw;\n      if (accumulator.pitch) params.pitch = accumulator.pitch;\n      zeroChanges(accumulator);\n\n      if (mergeState) {\n        // Okay, so if we just merge changes, that totally breaks mouse interaction\n        // because provided dPhi will zero out dPhi resulting from mouse interaction.\n        // It would be better to accumulate mouse pixel changes separately and then\n        // add this in afterwards, but since we've accumulated dPhi etc right in the\n        // params, we need to cache this, then merge changes, then add these back in\n        // if necessary. Consider this a low-priority cleanup item.\n        var cachedDPhi = params.dPhi;\n        var cachedDTheta = params.dTheta;\n        var cachedZoom = params.zoom;\n        var cachedPanX = params.panX;\n        var cachedPanY = params.panY;\n        var cachedPanZ = params.panZ;\n        var cachedPitch = params.pitch;\n        var cachedYaw = params.yaw;\n\n        // This merges anything and everything in the params vector.\n        Object.assign(params, mergeState);\n\n        // Yup, so add them back in.\n        if (mergeState.dPhi !== undefined) params.dPhi += cachedDPhi;\n        if (mergeState.dTheta !== undefined) params.dTheta += cachedDTheta;\n        if (mergeState.zoom !== undefined) params.zoom += cachedZoom;\n        if (mergeState.panX !== undefined) params.panX += cachedPanX;\n        if (mergeState.panY !== undefined) params.panY += cachedPanY;\n        if (mergeState.panZ !== undefined) params.panZ += cachedPanZ;\n        if (mergeState.pitch !== undefined) params.pitch += cachedPitch;\n        if (mergeState.yaw !== undefined) params.yaw += cachedYaw;\n      }\n\n      // Check for and apply passive changes to the params vector. That is, if you\n      // set camera.params.distance, this will automatically factor in those changes.\n      if (paramsVectorHasChanged()) {\n        applyStateChanges();\n      }\n\n      // Check if the view is changing above some threshold tolerance.\n      if (viewIsChanging()) {\n        // If so, update the view.\n        applyViewChanges(params);\n      } else {\n        // If not, fully zero it out.\n        zeroChanges(params);\n      }\n\n      // Not the highest resolution timer, but we only use it for inertia decay.\n      var t = Date.now();\n      if (t0 !== null) decay(t - t0);\n      t0 = t;\n\n      // Transfer this flag in a subtle way so that camera.params.dirty is writable.\n      camera.state.dirty = willBeDirty;\n      willBeDirty = false;\n\n      storeCurrentState();\n    },\n    taint: taint,\n    resize: resize,\n    params: params,\n    rotate: rotate,\n    pivot: pivot,\n    pan: pan,\n    zoom: zoom,\n  };\n\n  camera.state = {\n  };\n\n  camera.state.projection = new Float32Array(16);\n  camera.state.viewInv = new Float32Array(16);\n  camera.state.view = new Float32Array(16);\n  camera.state.width = null;\n  camera.state.height = null;\n  camera.state.eye = new Float32Array(3);\n\n  // Vectors used but not exposed. Not they couldn't be, but you can get these\n  // from the view matrix just fine.\n  var tmp = new Float32Array(3);\n  var viewUp = new Float32Array(3);\n  var viewRight = new Float32Array(3);\n  var viewForward = new Float32Array(3);\n  var origin = new Float32Array(3);\n  var dView = new Float32Array(16);\n\n  // Track the previous params so that we can detect changes in these parameters\n  var previousState = {\n    up: new Float32Array(3),\n    center: new Float32Array(3)\n  };\n  storeCurrentState();\n\n  function storeCurrentState () {\n    vec3Copy(previousState.up, params.up);\n    vec3Copy(previousState.center, params.center);\n    previousState.near = params.near;\n    previousState.far = params.far;\n    previousState.distance = params.distance;\n    previousState.phi = params.phi;\n    previousState.theta = params.theta;\n    previousState.fovY = params.fovY;\n  }\n\n  function paramsVectorHasChanged () {\n    if (!vec3Equals(params.up, previousState.up)) return true;\n    if (!vec3Equals(params.center, previousState.center)) return true;\n    if (params.near !== previousState.near) return true;\n    if (params.far !== previousState.far) return true;\n    if (params.phi !== previousState.phi) return true;\n    if (params.theta !== previousState.theta) return true;\n    if (params.distance !== previousState.distance) return true;\n    if (params.fovY !== previousState.fovY) return true;\n    return false;\n  }\n\n  var paramsChanges = {};\n  function applyStateChanges () {\n    paramsChanges.dPhi = params.phi - previousState.phi;\n    paramsChanges.dTheta = params.theta - previousState.theta;\n    paramsChanges.zoom = params.distance / previousState.distance - 1;\n    params.theta = previousState.theta;\n    params.distance = previousState.distance;\n    params.phi = previousState.phi;\n    paramsChanges.yaw = 0;\n    paramsChanges.pitch = 0;\n    paramsChanges.panX = 0;\n    paramsChanges.panY = 0;\n    paramsChanges.panZ = 0;\n    paramsChanges.mouseX = 0;\n    paramsChanges.mouseY = 0;\n\n    applyViewChanges(paramsChanges);\n  }\n\n  // The meat of it. Note that this function is intentionally very simple! There must\n  // not be any logic or complexity to this function. The complexity is in moving this\n  // view, not constructing it.\n  function computeMatrices () {\n    // Spherical coords\n    camera.state.eye[0] = 0;\n    camera.state.eye[1] = 0;\n    camera.state.eye[2] = params.distance;\n    vec3RotateX(camera.state.eye, camera.state.eye, origin, -params.phi);\n    vec3RotateY(camera.state.eye, camera.state.eye, origin, params.theta);\n    vec3Add(camera.state.eye, camera.state.eye, params.center);\n\n    // View + projection\n    lookAt(camera.state.view, camera.state.eye, params.center, params.up);\n    perspective(camera.state.projection, params.fovY, camera.params.aspectRatio, params.near, params.far);\n\n    // For convenience, but also because we already use this, so let's just expose it\n    mat4Invert(camera.state.viewInv, camera.state.view);\n  }\n\n  // Track this not on the params itself so that you can write camera.params.dirty\n  function taint () {\n    willBeDirty = true;\n  }\n\n  function resize (aspectRatio) {\n    camera.params.aspectRatio = aspectRatio\n    computeMatrices();\n    taint();\n  }\n\n  // All of these are mosty unitless, proportional, or at least relative to a window\n  // size that doesn't change much so that fixed tolerances seem fine.\n  function viewIsChanging () {\n    if (Math.abs(params.zoom) > 1e-4) return true;\n    if (Math.abs(params.panX) > 1e-4) return true;\n    if (Math.abs(params.panY) > 1e-4) return true;\n    if (Math.abs(params.panZ) > 1e-4) return true;\n    if (Math.abs(params.dTheta) > 1e-4) return true;\n    if (Math.abs(params.dPhi) > 1e-4) return true;\n    if (Math.abs(params.yaw) > 1e-4) return true;\n    if (Math.abs(params.pitch) > 1e-4) return true;\n  }\n\n  function zeroChanges (obj) {\n    obj.zoom = 0;\n    obj.dTheta = 0;\n    obj.dPhi = 0;\n    obj.panX = 0;\n    obj.panY = 0;\n    obj.panZ = 0;\n    obj.yaw = 0;\n    obj.pitch = 0;\n  }\n\n  // Exponential decay. Basically time-correct proportional decay.\n  function decay (dt) {\n    var panDecay = params.panDecayTime ? Math.exp(-dt / params.panDecayTime / Math.LN2) : 0;\n    var zoomDecay = params.zoomDecayTime ? Math.exp(-dt / params.zoomDecayTime / Math.LN2) : 0;\n    var rotateDecay = params.rotationDecayTime ? Math.exp(-dt / params.rotationDecayTime / Math.LN2) : 0;\n    params.zoom *= zoomDecay;\n    params.panX *= panDecay;\n    params.panY *= panDecay;\n    params.panZ *= panDecay;\n    params.dTheta *= rotateDecay;\n    params.dPhi *= rotateDecay;\n    params.yaw *= rotateDecay;\n    params.pitch *= rotateDecay;\n  }\n\n  // Accumulate changes per-frame since it turns out that Safari dispatches mouse events\n  // more than once per RAF while chrome sticks to strictly once per RAF. How surprising!\n  var accumulator = {};\n  zeroChanges(accumulator);\n\n  function pan (panX, panY) {\n    var scaleFactor = camera.params.distance * Math.tan(camera.params.fovY * 0.5) * 2.0;\n    accumulator.panX += panX * params.aspectRatio * scaleFactor;\n    accumulator.panY += panY * scaleFactor;\n    return camera;\n  }\n\n  function zoom (mouseX, mouseY, zoom) {\n    accumulator.zoom += zoom;\n    params.mouseX = mouseX;\n    params.mouseY = mouseY;\n    return camera;\n  }\n\n  function pivot (yaw, pitch) {\n    var scaleFactor = camera.params.fovY;\n    accumulator.yaw += yaw * scaleFactor * params.aspectRatio;\n    accumulator.pitch += pitch * scaleFactor;\n  }\n\n  function rotate (dTheta, dPhi) {\n    accumulator.dTheta += dTheta;\n    accumulator.dPhi += dPhi;\n  }\n\n  function applyViewChanges (changes) {\n    var zoomScaleFactor;\n\n    // Initialize a veiw-space transformation for panning and zooming\n    mat4Identity(dView);\n\n    // Zoom about the mouse location in view-space\n    if (params.zoomAboutCursor) {\n      zoomScaleFactor = params.distance * Math.tan(params.fovY * 0.5);\n      tmp[0] = changes.mouseX * params.aspectRatio * zoomScaleFactor;\n      tmp[1] = changes.mouseY * zoomScaleFactor;\n      tmp[2] = 0;\n      mat4Translate(dView, dView, tmp);\n    }\n\n    tmp[0] = 1 + changes.zoom;\n    tmp[1] = 1 + changes.zoom;\n    tmp[2] = 1;\n    mat4Scale(dView, dView, tmp);\n\n    if (params.zoomAboutCursor) {\n      zoomScaleFactor = params.distance * Math.tan(params.fovY * 0.5);\n      tmp[0] = -changes.mouseX * params.aspectRatio * zoomScaleFactor;\n      tmp[1] = -changes.mouseY * zoomScaleFactor;\n      tmp[2] = 0;\n      mat4Translate(dView, dView, tmp);\n    }\n\n    // Pan the view matrix\n    dView[12] -= changes.panX * 0.5;\n    dView[13] -= changes.panY * 0.5;\n\n    // transform into view space, then transfor, then invert again\n    transformMat4(params.center, params.center, camera.state.view);\n    transformMat4(params.center, params.center, dView);\n    transformMat4(params.center, params.center, camera.state.viewInv);\n\n    // If rotating about the center of the screen, then copy center -> rotationCenter\n    if (params.rotateAboutCenter) {\n      vec3Copy(params.rotationCenter, params.center);\n    }\n\n    params.distance *= 1 + changes.zoom;\n\n    var prevPhi = params.phi;\n    params.phi += changes.dPhi;\n    params.phi = Math.min(MAX_PHI, Math.max(MIN_PHI, params.phi));\n    var dPhi = params.phi - prevPhi;\n\n    var prevTheta = params.theta;\n    params.theta += changes.dTheta;\n    var dTheta = params.theta - prevTheta;\n\n    vec3RotateY(params.center, params.center, params.rotationCenter, dTheta - params.theta);\n    vec3RotateX(params.center, params.center, params.rotationCenter, -dPhi);\n    vec3RotateY(params.center, params.center, params.rotationCenter, params.theta);\n\n    if (changes.yaw !== 0 || changes.pitch !== 0) {\n      viewRight[0] = camera.state.view[0];\n      viewRight[1] = camera.state.view[4];\n      viewRight[2] = camera.state.view[8];\n      vec3Normalize(viewRight, viewRight);\n\n      viewUp[0] = camera.state.view[1];\n      viewUp[1] = camera.state.view[5];\n      viewUp[2] = camera.state.view[9];\n      vec3Normalize(viewUp, viewUp);\n\n      viewForward[0] = camera.state.view[2];\n      viewForward[1] = camera.state.view[6];\n      viewForward[2] = camera.state.view[10];\n      vec3Normalize(viewForward, viewForward);\n\n      var clippedPhi = Math.min(MAX_PHI, Math.max(MIN_PHI, params.phi + changes.pitch * 0.5));\n      var clippedPitch = clippedPhi - params.phi;\n\n      vec3ScaleAndAdd(params.center, params.center, viewRight, -Math.sin(changes.yaw * 0.5) * params.distance);\n      vec3ScaleAndAdd(params.center, params.center, viewUp, -Math.sin(clippedPitch) * params.distance);\n      vec3ScaleAndAdd(params.center, params.center, viewForward, (2 - Math.cos(changes.yaw * 0.5) - Math.cos(clippedPitch)) * params.distance);\n      params.phi = clippedPhi;\n      params.theta += changes.yaw * 0.5;\n    }\n\n    computeMatrices();\n    taint();\n  }\n\n  resize(camera.params.aspectRatio);\n\n  return camera;\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/inertial-turntable-camera/index.js?");

/***/ }),

/***/ "./node_modules/stats.js/build/stats.min.js":
/*!**************************************************!*\
  !*** ./node_modules/stats.js/build/stats.min.js ***!
  \**************************************************/
/***/ (function(module) {

eval("// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){ true?module.exports=e():0})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/stats.js/build/stats.min.js?");

/***/ }),

/***/ "./src/cameras/InertialTurntableCamera.ts":
/*!************************************************!*\
  !*** ./src/cameras/InertialTurntableCamera.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InertialTurntableCamera: () => (/* binding */ InertialTurntableCamera)\n/* harmony export */ });\n/* harmony import */ var webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgpu-matrix */ \"./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js\");\n\n/**\n * This class is a wrapper around the inertial-turntable-camera library. See {@link https://github.com/standardCyborg/inertial-turntable-camera}.\n */\nclass InertialTurntableCamera {\n    fov;\n    aspect;\n    near;\n    far;\n    camera; // No type information available for InertialTurntableCamera\n    initialParams;\n    // same as BlenderCamera\n    constructor(fov, aspect, near, far) {\n        this.fov = fov;\n        this.aspect = aspect;\n        this.near = near;\n        this.far = far;\n        this.camera = __webpack_require__(/*! inertial-turntable-camera */ \"./node_modules/inertial-turntable-camera/index.js\")();\n        this.initialParams = {\n            center: webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(0, 0, 0),\n            phi: 0,\n            theta: 0,\n            distance: 10,\n            rotateAboutCenter: true,\n            fovY: fov,\n            aspectRatio: aspect,\n            near: near,\n            far: far,\n        };\n        this.tick(this.initialParams);\n    }\n    reset() {\n        this.tick(this.initialParams);\n    }\n    pan(x, y) {\n        this.camera.pan(x, y);\n    }\n    pivot(x, y) {\n        this.camera.pivot(x, y);\n    }\n    rotate(x, y) {\n        this.camera.rotate(x, y);\n    }\n    zoom(x, y, z) {\n        this.camera.zoom(x, y, z);\n    }\n    /**\n     * Updates the camera matrices.\n     * Passed parameters are used to update the camera matrices.\n     * @param params Parameters to update the camera matrices.\n     */\n    tick(params) {\n        this.camera.tick(params);\n    }\n    resize(aspectRatio) {\n        this.camera.resize(aspectRatio);\n    }\n    getParams() {\n        return this.camera.params;\n    }\n    getProjectionMatrix() {\n        return this.camera.state.projection;\n    }\n    getViewMatrix() {\n        return this.camera.state.view;\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/cameras/InertialTurntableCamera.ts?");

/***/ }),

/***/ "./src/cameras/InputHandler-InertialTurntableCamera.ts":
/*!*************************************************************!*\
  !*** ./src/cameras/InputHandler-InertialTurntableCamera.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputHandlerInertialTurntableCamera: () => (/* binding */ InputHandlerInertialTurntableCamera)\n/* harmony export */ });\n/**\n * Input Event handler that controls a {@link InertialTurntableCamera} instance.\n */\nclass InputHandlerInertialTurntableCamera {\n    canvas;\n    camera;\n    panSpeed = 0.001;\n    radiansPerHalfScreenWidth = Math.PI * 0.5;\n    rotationSpeed = 0.001;\n    /**\n     * Creates an input handler for moving the camera. The camera is assumed to be an InertialTurntableCamera.\n     * @param canvas The HTMLCanvas element that webGPU draws to.\n     * @param camera The {@link InertialTurntableCamera} instance that is used as the camera for WebGPU.\n     */\n    constructor(canvas, camera) {\n        this.canvas = canvas;\n        this.camera = camera;\n    }\n    registerInputHandlers() {\n        console.log(\"Registering input handlers\");\n        this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));\n        this.canvas.addEventListener('wheel', this.handleScroll.bind(this));\n    }\n    handlePointerMove(event) {\n        // left click to rotate camera\n        if (event.buttons === 1) {\n            if (event.shiftKey) {\n                this.camera.pan(event.movementX * this.panSpeed, -event.movementY * this.panSpeed);\n            }\n            else if (event.metaKey) {\n                this.camera.pivot(event.movementX, event.movementY);\n            }\n            else {\n                this.camera.rotate(-event.movementX * this.radiansPerHalfScreenWidth * this.rotationSpeed, event.movementY * this.radiansPerHalfScreenWidth * this.rotationSpeed);\n            }\n        }\n        event.preventDefault();\n    }\n    handleScroll(event) {\n        this.camera.zoom(0, 0, event.deltaY / 10000);\n        event.preventDefault();\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/cameras/InputHandler-InertialTurntableCamera.ts?");

/***/ }),

/***/ "./src/dataHandling/Batch.ts":
/*!***********************************!*\
  !*** ./src/dataHandling/Batch.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Batch: () => (/* binding */ Batch)\n/* harmony export */ });\n/* harmony import */ var webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgpu-matrix */ \"./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js\");\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util */ \"./src/utils/util.ts\");\n\n\n/**\n * One Batch with a set number of points.\n * Used in the {@Link BatchHandler} container class.\n */\nclass Batch {\n    /**\n     * Bounding box of the batch. The bounding box is an array of 6 numbers: [minX, minY, minZ, maxX, maxY, maxZ].\n     * @private\n     */\n    _boundingBox;\n    /**\n     * Size of the batch in 3D space. The size is an array of 3 numbers: [sizeX, sizeY, sizeZ].\n     * @private\n     */\n    _size;\n    /**\n     * The number of points in the batch.\n     * @private\n     */\n    _filledSize;\n    /**\n     * The maximum number of points in the batch.\n     * @private\n     */\n    batchSize;\n    /**\n     * The amount of bytes in the buffer that can be loaded into the Batch. The batch itself will split this into the different buffers.\n     * @private\n     */\n    _bufferSize;\n    /**\n     * The screen size in pixels.\n     * @private\n     */\n    _screenSize;\n    /**\n     * The id of the batch.\n     * @private\n     */\n    _id;\n    lastUsedMVP;\n    transformedCornersCache;\n    /** The GPU buffer containing the points of the batch. The course buffer contains the 10 most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    gpuBuffer_coarse;\n    /** The GPU buffer containing the points of the batch. The medium buffer contains the 10th to 20th most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    gpuBuffer_medium;\n    /** The GPU buffer containing the points of the batch. The fine buffer contains the 20th to 30th most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    gpuBuffer_fine;\n    /** The GPU buffer containing the colors for the points of the batch. **/\n    gpuBuffer_color;\n    /** The Host buffer containing the points of the batch. The course buffer contains the 10 most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    hostBuffer_coarse;\n    /** The Host buffer containing the points of the batch. The medium buffer contains the 10th to 20th most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    hostBuffer_medium;\n    /** The Host buffer containing the points of the batch. The fine buffer contains the 20th to 30th most significant bits of x, y and z as distances from the {@link _boundingBox} origin. **/\n    hostBuffer_fine;\n    /** The Host buffer containing the colors for the points of the batch. **/\n    hostBuffer_color;\n    /**\n     * Bind groups for the depth render passes. One bind group per different shader.\n     * This is initialised when the buffer is written to the GPU.\n     *\n     * Index 0: coarse\n     * Index 1: medium\n     * Index 2: fine\n     *\n     * @private\n     */\n    bindGroups_depth;\n    /**\n     * Bind groups for the render passes. One bind group per different shader.\n     * This is initialised when the buffer is written to the GPU.\n     *\n     * Index 0: coarse\n     * Index 1: medium\n     * Index 2: fine\n     *\n     * @private\n     */\n    bindGroups_rendering;\n    buffersReadyToWrite;\n    buffersInFlight;\n    buffersWrittenToGPU;\n    _compute_depth_shader_bindGroupLayouts;\n    _compute_shader_bindGroupLayouts;\n    _uniformBuffer;\n    _depthBuffer;\n    _frameBuffer;\n    _device;\n    constructor(device, uniformBuffer, depthBuffer, frameBuffer, compute_depth_shader_bindGroupLayouts, compute_shader_bindGroupLayouts, bufferSize, screenSize, id) {\n        console.log(\"Creating new batch with size\", bufferSize);\n        // Number of this Batch for debugging\n        this._id = id;\n        this._device = device;\n        this._uniformBuffer = uniformBuffer;\n        this._depthBuffer = depthBuffer;\n        this._frameBuffer = frameBuffer;\n        this._compute_depth_shader_bindGroupLayouts = compute_depth_shader_bindGroupLayouts;\n        this._compute_shader_bindGroupLayouts = compute_shader_bindGroupLayouts;\n        this._bufferSize = bufferSize;\n        this._screenSize = screenSize;\n        this.batchSize = bufferSize / 16;\n        this.gpuBuffer_coarse = this.makeGPUBuffer(this.batchSize, \"coarse\");\n        this.gpuBuffer_medium = this.makeGPUBuffer(this.batchSize, \"medium\");\n        this.gpuBuffer_fine = this.makeGPUBuffer(this.batchSize, \"fine\");\n        this.gpuBuffer_color = this.makeGPUBuffer(this.batchSize, \"color\");\n        this.hostBuffer_coarse = new Uint32Array(this.batchSize);\n        this.hostBuffer_medium = new Uint32Array(this.batchSize);\n        this.hostBuffer_fine = new Uint32Array(this.batchSize);\n        this.hostBuffer_color = new Uint32Array(this.batchSize);\n        this.buffersReadyToWrite = false;\n        this.buffersInFlight = false;\n        this.buffersWrittenToGPU = false;\n        const b0 = Infinity;\n        this._boundingBox = [b0, b0, b0, -b0, -b0, -b0];\n        this._size = [0, 0, 0];\n        this._filledSize = 0;\n        this.lastUsedMVP = new Float32Array(16);\n        this.transformedCornersCache = new Float32Array(24);\n    }\n    /**\n     * Create the GPU Buffer to hold the loaded points.\n     * @param number_of_points the number of points in the batch. This controls the size of the buffer using the size per element.\n     * @param label label of the buffer used for debugging.\n     * @private\n     */\n    makeGPUBuffer(number_of_points, label) {\n        return this._device.createBuffer({\n            label: label,\n            size: number_of_points * Uint32Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n    }\n    /**\n     * Load points into the batch. Each point has to be processed into a fine, medium and coarse representation and then loaded into the corresponding GPU buffer.\n     * The bounding box {@link _boundingBox} and the size of the batch are also updated.\n     * @param data The points to load in the format: [x1, y1, z1, c1, x2, y2, z2, c2, ...]\n     * x, y, z are the coordinates of the point and c is the color of the point.\n     * x, y, z are f32 and c is an uint32.\n     */\n    async loadData(data) {\n        const numPoints = data.byteLength / 16;\n        const numPointsToLoad = Math.min(numPoints, this.batchSize - this._filledSize);\n        // find bounding box\n        const boundingBoxFound = this.findBoundingBox(data, numPointsToLoad);\n        // Process the points and load them into the host buffers.\n        const courseView = new DataView(this.hostBuffer_coarse.buffer);\n        const mediumView = new DataView(this.hostBuffer_medium.buffer);\n        const fineView = new DataView(this.hostBuffer_fine.buffer);\n        const colorView = new DataView(this.hostBuffer_color.buffer);\n        await boundingBoxFound;\n        const boxSize = this.getBoxSize();\n        const origin = this.getOrigin();\n        // print the bounding box\n        // console.log(\"Bounding box: \", this._boundingBox);\n        // console.log(\"Size: \", boxSize);\n        // console.log(\"Origin: \", origin);\n        const factor = 2 ** 30; // 0b0100_0000_0000_0000_0000_0000_0000_0000\n        const bitmask30 = factor - 1; // 0b0011_1111_1111_1111_1111_1111_1111_1111\n        const dataView = new DataView(data);\n        for (let i = 0; i < numPointsToLoad; i++) {\n            const x = dataView.getFloat32(i * 16, true);\n            const y = dataView.getFloat32(i * 16 + 4, true);\n            const z = dataView.getFloat32(i * 16 + 8, true);\n            const c = dataView.getUint32(i * 16 + 12, true);\n            // relate to bounding box origin\n            let xDist = x - origin[0];\n            let yDist = y - origin[1];\n            let zDist = z - origin[2];\n            // transform to [0, 1]\n            if (xDist !== 0) {\n                xDist = xDist / boxSize[0];\n            }\n            if (yDist !== 0) {\n                yDist = yDist / boxSize[1];\n            }\n            if (zDist !== 0) {\n                zDist = zDist / boxSize[2];\n            }\n            // transform to [0, 2^32]\n            xDist = Math.floor(xDist * bitmask30);\n            yDist = Math.floor(yDist * bitmask30);\n            zDist = Math.floor(zDist * bitmask30);\n            // read out coarse, medium and fine\n            const coarseX = (xDist >> 20) & 0x3FF;\n            const coarseY = (yDist >> 20) & 0x3FF;\n            const coarseZ = (zDist >> 20) & 0x3FF;\n            courseView.setUint32(i * 4, (coarseX << 20) | (coarseY << 10) | coarseZ, true);\n            const mediumX = (xDist >> 10) & 0x3FF;\n            const mediumY = (yDist >> 10) & 0x3FF;\n            const mediumZ = (zDist >> 10) & 0x3FF;\n            mediumView.setUint32(i * 4, (mediumX << 20) | (mediumY << 10) | mediumZ, true);\n            const fineX = (xDist >> 0) & 0x3FF;\n            const fineY = (yDist >> 0) & 0x3FF;\n            const fineZ = (zDist >> 0) & 0x3FF;\n            fineView.setUint32(i * 4, (fineX << 20) | (fineY << 10) | fineZ, true);\n            // color[i] = c;\n            colorView.setUint32(i * 4, c, true);\n        }\n        // Buffer is ready to be written to the GPU. Can be done in the render loop so only one Buffer is written per frame.\n        this.buffersReadyToWrite = true;\n        this._filledSize += numPointsToLoad;\n        return;\n    }\n    /**\n     * Write the data of the buffer to the GPU. This function exists so the load of transferring data to the GPU can be spread out over multiple frames.\n     * The host buffer may be destroyed after it is copied to the GPU buffer to save memory.\n     *\n     * @param deleteHostBuffer_ifFull If true, the host buffer will be destroyed if it is full.\n     */\n    async writeDataToGPUBuffer(deleteHostBuffer_ifFull = false) {\n        if (this.buffersReadyToWrite && !this.buffersInFlight) {\n            this._device.queue.writeBuffer(this.gpuBuffer_coarse, 0, this.hostBuffer_coarse.buffer, 0, this.hostBuffer_coarse.byteLength);\n            this._device.queue.writeBuffer(this.gpuBuffer_medium, 0, this.hostBuffer_medium.buffer, 0, this.hostBuffer_medium.byteLength);\n            this._device.queue.writeBuffer(this.gpuBuffer_fine, 0, this.hostBuffer_fine.buffer, 0, this.hostBuffer_fine.byteLength);\n            this._device.queue.writeBuffer(this.gpuBuffer_color, 0, this.hostBuffer_color.buffer, 0, this.hostBuffer_color.byteLength);\n            this.buffersInFlight = true;\n            this.create_bindGroups();\n            this._device.queue.onSubmittedWorkDone().then(() => {\n                // finished writing to GPU\n                this.buffersReadyToWrite = false;\n                this.buffersWrittenToGPU = true;\n                this.buffersInFlight = false;\n                console.log(`Finished writing ${this.gpuBuffer_coarse.size * 4} bytes of data to GPU buffer for Batch: `, this._id);\n                if (deleteHostBuffer_ifFull && this.isFull()) {\n                    this.destroyHostBuffers();\n                }\n            }).catch((error) => {\n                console.error(\"Error writing data to GPU buffer for Batch: \", this._id, error);\n            });\n        }\n    }\n    /**\n     * Get the origin of the batch in 3D space. The origin is an array of 3 numbers: [originX, originY, originZ].\n     */\n    getOrigin() {\n        return [\n            this._boundingBox[0],\n            this._boundingBox[1],\n            this._boundingBox[2]\n        ];\n    }\n    /**\n     * Get the size of the batch in 3D space. The size is an array of 3 numbers: [sizeX, sizeY, sizeZ].\n     */\n    getBoxSize() {\n        return this._size;\n    }\n    getCoarseGPUBuffer() {\n        return this.gpuBuffer_coarse;\n    }\n    getMediumGPUBuffer() {\n        return this.gpuBuffer_medium;\n    }\n    getFineGPUBuffer() {\n        return this.gpuBuffer_fine;\n    }\n    getColorGPUBuffer() {\n        return this.gpuBuffer_color;\n    }\n    /**\n     * Destroy the GPU buffers of the batch.\n     */\n    destroyGPUBuffers() {\n        this.gpuBuffer_coarse.destroy();\n        this.gpuBuffer_medium.destroy();\n        this.gpuBuffer_fine.destroy();\n        this.gpuBuffer_color.destroy();\n    }\n    /**\n     * Destroy the host buffers of the batch.\n     */\n    destroyHostBuffers() {\n        delete this.hostBuffer_coarse;\n        delete this.hostBuffer_medium;\n        delete this.hostBuffer_fine;\n        delete this.hostBuffer_color;\n        console.log(\"Deleted host buffers for batch: \", this._id, \"\\ttotaling\", this._bufferSize * 4 * 4 / (1024 ** 2), \"MB\");\n    }\n    /**\n     * Find the bounding box of the batch. The bounding box is an array of 6 numbers: [minX, minY, minZ, maxX, maxY, maxZ].\n     * @param data The data to find the bounding box of.\n     * @param numPointsToLoad The number of points to load.\n     * @private\n     */\n    async findBoundingBox(data, numPointsToLoad) {\n        const dataView = new DataView(data);\n        for (let i = 0; i < numPointsToLoad; i++) {\n            const x = dataView.getFloat32(i * 16, true);\n            const y = dataView.getFloat32(i * 16 + 4, true);\n            const z = dataView.getFloat32(i * 16 + 8, true);\n            if (this._boundingBox[0] > x)\n                this._boundingBox[0] = x;\n            if (this._boundingBox[1] > y)\n                this._boundingBox[1] = y;\n            if (this._boundingBox[2] > z)\n                this._boundingBox[2] = z;\n            if (this._boundingBox[3] < x)\n                this._boundingBox[3] = x;\n            if (this._boundingBox[4] < y)\n                this._boundingBox[4] = y;\n            if (this._boundingBox[5] < z)\n                this._boundingBox[5] = z;\n        }\n        this._size = [\n            (this._boundingBox[3] - this._boundingBox[0]),\n            (this._boundingBox[4] - this._boundingBox[1]),\n            (this._boundingBox[5] - this._boundingBox[2])\n        ];\n    }\n    /**\n     * Write the uniform data to the uniform buffer. The render mode is used to determine the level of detail to render.\n     * This function should be called before rendering the batch.\n     * @param renderMode 0: coarse, 1: medium, 2: fine.\n     */\n    getUniformData(renderMode) {\n        // Update the uniform data\n        const origin = this.getOrigin();\n        const size = this.getBoxSize();\n        const uniformData = {\n            origin: webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(origin[0], origin[1], origin[2], 0),\n            size: webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(size[0], size[1], size[2], 0),\n            renderMode: renderMode,\n        };\n        const uniformArray = new Float32Array(4 * 2 + 1);\n        const uniformArrayView = new DataView(uniformArray.buffer);\n        uniformArrayView.setFloat32(0, uniformData.origin[0], true);\n        uniformArrayView.setFloat32(4, uniformData.origin[1], true);\n        uniformArrayView.setFloat32(8, uniformData.origin[2], true);\n        uniformArrayView.setFloat32(16, uniformData.size[0], true);\n        uniformArrayView.setFloat32(20, uniformData.size[1], true);\n        uniformArrayView.setFloat32(24, uniformData.size[2], true);\n        uniformArrayView.setUint32(32, uniformData.renderMode, true);\n    }\n    /**\n     * Transform the eight corners of the bounding box into screen space. The corners are transformed by the model view projection matrix.\n     * @param mvp The model view projection matrix.\n     * @returns The transformed bounding box corners. The format is [x1, y1, z1, x2, y2, z2, ...]\n     */\n    getBoundingBoxOnScreen(mvp) {\n        if (webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.equalsApproximately(mvp, this.lastUsedMVP)) {\n            if (this.transformedCornersCache)\n                return this.transformedCornersCache;\n        }\n        const corners = [\n            this._boundingBox[0], this._boundingBox[1], this._boundingBox[2],\n            this._boundingBox[3], this._boundingBox[1], this._boundingBox[2],\n            this._boundingBox[0], this._boundingBox[4], this._boundingBox[2],\n            this._boundingBox[3], this._boundingBox[4], this._boundingBox[2],\n            this._boundingBox[0], this._boundingBox[1], this._boundingBox[5],\n            this._boundingBox[3], this._boundingBox[1], this._boundingBox[5],\n            this._boundingBox[0], this._boundingBox[4], this._boundingBox[5],\n            this._boundingBox[3], this._boundingBox[4], this._boundingBox[5],\n        ];\n        const transformedCorners = new Float32Array(24);\n        for (let i = 0; i < 8; i++) {\n            const corner = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(corners[i * 3], corners[i * 3 + 1], corners[i * 3 + 2], 1.0);\n            const transformedCorner = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.create();\n            webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.transformMat4(corner, mvp, transformedCorner);\n            const ndc = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.create();\n            webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.scale(transformedCorner, 1 / transformedCorner[3], ndc);\n            if (ndc[3] <= 0) {\n                transformedCorner[i * 3 + 0] = 0;\n                transformedCorner[i * 3 + 1] = 0;\n                transformedCorner[i * 3 + 2] = ndc[3];\n                continue;\n            }\n            // Convert ndc to screen space coordinates\n            const screen_x = (ndc[0] * 0.5 + 0.5) * this._screenSize[0];\n            const screen_y = (ndc[1] * 0.5 + 0.5) * this._screenSize[1];\n            transformedCorners[i * 3] = screen_x;\n            transformedCorners[i * 3 + 1] = screen_y;\n            transformedCorners[i * 3 + 2] = ndc[3];\n        }\n        webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.copy(mvp, this.lastUsedMVP);\n        this.transformedCornersCache = transformedCorners;\n        return transformedCorners;\n    }\n    NDC_BoundingBox_cached = null;\n    /**\n     * Gets the bounding box of the batch in NDC space. The bounding box is an array of 8 numbers: [x1, y1, z1, x2, y2, z2, ...]\n     *\n     * <b>NOTE:</b> Because this function gets called before {@link getBoundingBoxOnScreen}, the last used MVP matrix should not be updated here.\n     *\n     * @param mvp\n     */\n    getBoundingBoxInNDC(mvp) {\n        if (webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.equalsApproximately(mvp, this.lastUsedMVP)) {\n            if (this.NDC_BoundingBox_cached)\n                return this.NDC_BoundingBox_cached;\n        }\n        const corners = [\n            [this._boundingBox[0], this._boundingBox[1], this._boundingBox[2]],\n            [this._boundingBox[3], this._boundingBox[1], this._boundingBox[2]],\n            [this._boundingBox[0], this._boundingBox[4], this._boundingBox[2]],\n            [this._boundingBox[3], this._boundingBox[4], this._boundingBox[2]],\n            [this._boundingBox[0], this._boundingBox[1], this._boundingBox[5]],\n            [this._boundingBox[3], this._boundingBox[1], this._boundingBox[5]],\n            [this._boundingBox[0], this._boundingBox[4], this._boundingBox[5]],\n            [this._boundingBox[3], this._boundingBox[4], this._boundingBox[5]],\n        ];\n        const transformedCorners = new Float32Array(24);\n        for (let i = 0; i < 8; i++) {\n            const corner = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.fromValues(corners[i][0], corners[i][1], corners[i][2], 1.0);\n            const transformedCorner = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.create();\n            webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.transformMat4(corner, mvp, transformedCorner);\n            const ndc = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.create();\n            webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec4.scale(transformedCorner, 1 / transformedCorner[3], ndc);\n            transformedCorners[i * 3] = ndc[0];\n            transformedCorners[i * 3 + 1] = ndc[1];\n            transformedCorners[i * 3 + 2] = ndc[2];\n        }\n        // update the cached value\n        // mat4.copy(transformedCorners, this.NDC_BoundingBox_cached); // Do not updated here!\n        this.NDC_BoundingBox_cached = transformedCorners;\n        return transformedCorners;\n    }\n    /**\n     * Check if the batch is in the view frustum. This is checked in NDC space.\n     *\n     * @param mvp The model view projection matrix.\n     * @returns True if the batch is on screen, false otherwise.\n     */\n    isInFrustum(mvp) {\n        const ndcCorners = this.getBoundingBoxInNDC(mvp);\n        let ndcMin = [Infinity, Infinity, Infinity];\n        let ndcMax = [-Infinity, -Infinity, -Infinity];\n        let hasValidCoords = false;\n        for (let i = 0; i < 8; i++) {\n            const x = ndcCorners[i * 3];\n            const y = ndcCorners[i * 3 + 1];\n            const z = ndcCorners[i * 3 + 2];\n            // Skip invalid corners (behind camera, w <= 0 → marked as -Infinity earlier)\n            if (!isFinite(x) || !isFinite(y) || !isFinite(z))\n                continue;\n            ndcMin[0] = Math.min(ndcMin[0], x);\n            ndcMin[1] = Math.min(ndcMin[1], y);\n            ndcMin[2] = Math.min(ndcMin[2], z);\n            ndcMax[0] = Math.max(ndcMax[0], x);\n            ndcMax[1] = Math.max(ndcMax[1], y);\n            ndcMax[2] = Math.max(ndcMax[2], z);\n            hasValidCoords = true;\n        }\n        if (!hasValidCoords)\n            return false;\n        // Check intersection with the NDC cube [-1, 1] on all axes\n        return ndcMin[0] <= 1 && ndcMax[0] >= -1 &&\n            ndcMin[1] <= 1 && ndcMax[1] >= -1;\n        // && ndcMin[2] <= 1 && ndcMax[2] >= -1; // This seems to cause issues. I'll leave depth testing fully up to the GPU for now.\n    }\n    /**\n     * Returns the number of points actually loaded in the batch.\n     */\n    filledSize() {\n        return this._filledSize;\n    }\n    /**\n     * Returns true if the batch is full.\n     */\n    isFull() {\n        return this._filledSize >= this.batchSize;\n    }\n    /**\n     * Returns true if the Host buffers are ready to be written to the GPU and not currently in use (for example by another copy operation).\n     */\n    canBeWrittenToGPU() {\n        return this.buffersReadyToWrite && !this.buffersInFlight;\n    }\n    /**\n     * Returns true if the batch has been uploaded to the GPU.\n     */\n    isWrittenToGPU() {\n        return this.buffersWrittenToGPU;\n    }\n    /**\n     * The maximum number of {@bold Points} that can be loaded into the batch.\n     */\n    getBatchSize() {\n        return this.batchSize;\n    }\n    /**\n     * Get the id of the batch.\n     */\n    getID() {\n        return this._id;\n    }\n    /**\n     * Get the accuracy level of the batch. The accuracy level is determined by the size of the bounding box on screen.\n     * 0: coarse, 1: medium, 2: fine.\n     * @param mVP The model view projection matrix.\n     */\n    getAccuracyLevel(mVP) {\n        const cornersOnScreen = this.getBoundingBoxOnScreen(mVP);\n        // default to coarse level of detail\n        let accuracyLevel = 0;\n        let min_x = this._screenSize[0];\n        let max_x = 0;\n        let min_y = this._screenSize[1];\n        let max_y = 0;\n        for (let i = 0; i < 8; i++) {\n            const x = cornersOnScreen[i * 3];\n            const y = cornersOnScreen[i * 3 + 1];\n            if (x < min_x)\n                min_x = x;\n            if (x > max_x)\n                max_x = x;\n            if (y < min_y)\n                min_y = y;\n            if (y > max_y)\n                max_y = y;\n        }\n        const width = max_x - min_x;\n        const height = max_y - min_y;\n        // If bounding box is bigger than 1/8 of the screen, use medium level of detail\n        if (width > this._screenSize[0] / 8 || height > this._screenSize[1] / 8) {\n            accuracyLevel = 1;\n        }\n        // If bounding box is bigger than 1/4 of the screen, use fine level of detail\n        if (width > this._screenSize[0] / 4 || height > this._screenSize[1] / 4) {\n            accuracyLevel = 2;\n        }\n        return accuracyLevel;\n    }\n    /**\n     * Get the bounding box of the batch. The bounding box is an array of 6 numbers: [minX, minY, minZ, maxX, maxY, maxZ].\n     */\n    getBoundingBox() {\n        return this._boundingBox;\n    }\n    create_bindGroups() {\n        const buffers_for_depth = [\n            this._uniformBuffer,\n            this._depthBuffer,\n            this.getCoarseGPUBuffer()\n        ];\n        const buffers_for_compute = [\n            this._uniformBuffer,\n            this._depthBuffer,\n            this._frameBuffer,\n            this.getColorGPUBuffer(),\n            this.getCoarseGPUBuffer()\n        ];\n        this.bindGroups_depth = [];\n        this.bindGroups_rendering = [];\n        // coarse\n        this.bindGroups_depth.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_depth_shader_bindGroupLayouts[0], buffers_for_depth));\n        this.bindGroups_depth[0].label = 'bind group depth 0';\n        this.bindGroups_rendering.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_shader_bindGroupLayouts[0], buffers_for_compute));\n        this.bindGroups_rendering[0].label = 'bind group render 0';\n        // medium\n        buffers_for_compute.push(this.getMediumGPUBuffer());\n        buffers_for_depth.push(this.getMediumGPUBuffer());\n        this.bindGroups_depth.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_depth_shader_bindGroupLayouts[1], buffers_for_depth));\n        this.bindGroups_depth[1].label = 'bind group depth 1';\n        this.bindGroups_rendering.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_shader_bindGroupLayouts[1], buffers_for_compute));\n        this.bindGroups_rendering[1].label = 'bind group render 1';\n        // fine\n        buffers_for_compute.push(this.getFineGPUBuffer());\n        buffers_for_depth.push(this.getFineGPUBuffer());\n        this.bindGroups_depth.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_depth_shader_bindGroupLayouts[2], buffers_for_depth));\n        this.bindGroups_depth[2].label = 'bind group depth 2';\n        this.bindGroups_rendering.push(_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createBindGroup(this._device, this._compute_shader_bindGroupLayouts[2], buffers_for_compute));\n        this.bindGroups_rendering[2].label = 'bind group render 2';\n    }\n    get_depth_bindGroup(type) {\n        if (this.bindGroups_depth)\n            return this.bindGroups_depth[type];\n        return null;\n    }\n    get_compute_bindGroup(type) {\n        if (this.bindGroups_rendering)\n            return this.bindGroups_rendering[type];\n        return null;\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/dataHandling/Batch.ts?");

/***/ }),

/***/ "./src/dataHandling/BatchHandler.ts":
/*!******************************************!*\
  !*** ./src/dataHandling/BatchHandler.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BatchHandler: () => (/* binding */ BatchHandler)\n/* harmony export */ });\n/* harmony import */ var _Batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Batch */ \"./src/dataHandling/Batch.ts\");\n\nclass BatchHandler {\n    counter = 0;\n    _device;\n    _compute_depth_shader_bindGroupLayouts;\n    _compute_shader_bindGroupLayouts;\n    _uniformBuffer;\n    _depthBuffer;\n    _frameBuffer;\n    /**\n     * The maximum number of points in each batch.\n     * @private\n     */\n    _batchSize;\n    _batches;\n    _screenSize;\n    constructor(device, uniformBuffer, depthBuffer, frameBuffer, compute_depth_shader_bindGroupLayouts, compute_shader_bindGroupLayouts, batchSize, screenSize) {\n        this._device = device;\n        this._uniformBuffer = uniformBuffer;\n        this._depthBuffer = depthBuffer;\n        this._frameBuffer = frameBuffer;\n        this._compute_depth_shader_bindGroupLayouts = compute_depth_shader_bindGroupLayouts;\n        this._compute_shader_bindGroupLayouts = compute_shader_bindGroupLayouts;\n        this._batchSize = batchSize;\n        this._screenSize = screenSize;\n        this._batches = [];\n        this.addBatch();\n    }\n    /**\n     * Add a new empty {@link Batch} to the batch handler and returns the newly created {@link Batch} instance.\n     */\n    addBatch() {\n        this._batches.push(new _Batch__WEBPACK_IMPORTED_MODULE_0__.Batch(this._device, this._uniformBuffer, this._depthBuffer, this._frameBuffer, this._compute_depth_shader_bindGroupLayouts, this._compute_shader_bindGroupLayouts, this._batchSize, this._screenSize, this.counter++));\n        return this._batches[this._batches.length - 1];\n    }\n    /**\n     * For each batch in the batch handler, call the callback function with the batch as the argument.\n     * @param callback\n     */\n    forEachBatch(callback) {\n        this._batches.forEach(callback);\n    }\n    /**\n     * For each batch in the batch handler that is on screen, call the callback function with the batch as the argument.\n     * If the batch is on screen is determined by calling the {@link Batch.isInFrustum} method.\n     * @param mvp\n     * @param callback\n     */\n    forEachBatchOnScreen(mvp, callback) {\n        this._batches.forEach(batch => {\n            if (batch.isInFrustum(mvp)) {\n                callback(batch);\n            }\n        });\n    }\n    /**\n     * Get the batch at the given index.\n     * @param index\n     */\n    getBatch(index) {\n        return this._batches[index];\n    }\n    /**\n     * Get all the batches in the batch handler.\n     */\n    getBatches() {\n        return this._batches;\n    }\n    /**\n     * Add an arbitrary amount of data to the batch handler. The data is split into batches of size batchSize.\n     * @param data The {@link ArrayBuffer} of data to be added to the batch handler. Arbitrary length.\n     * @returns {Promise<void>} A promise that resolves when the data has been added to the batch handler.\n     */\n    async add(data) {\n        let remainingData = data;\n        while (remainingData.byteLength > 0) {\n            const currentBatch = this._batches[this._batches.length - 1];\n            const currentBatchFilledSize = currentBatch.filledSize();\n            const remainingSpace = this._batchSize - currentBatchFilledSize;\n            const dataToWrite = remainingData.slice(0, remainingSpace);\n            const wait = currentBatch.loadData(dataToWrite);\n            remainingData = remainingData.slice(remainingSpace);\n            if (remainingData.byteLength > 0) {\n                this.addBatch();\n            }\n            await wait;\n        }\n    }\n    /**\n     * Write the data of the first batch that can be written to the GPU to the GPU.\n     *\n     * This method is called once per frame to decrease initial loading time.\n     */\n    async writeOneBufferToGPU() {\n        for (let b of this._batches) {\n            if (b.canBeWrittenToGPU()) {\n                await b.writeDataToGPUBuffer(true);\n                return;\n            }\n        }\n    }\n    /**\n     * Get the number of batches in the batch handler.\n     */\n    numberOfBuffers() {\n        return this._batches.length;\n    }\n    /**\n     * Get the total model extent of all the batches. Has the form [minX, minY, minZ, maxX, maxY, maxZ].\n     * @returns {number[6]} The total model extent of all the batches.\n     */\n    getTotalModelExtent() {\n        let min = [Infinity, Infinity, Infinity];\n        let max = [-Infinity, -Infinity, -Infinity];\n        this._batches.forEach(batch => {\n            const modelExtent = batch.getBoundingBox();\n            if (modelExtent[0] < min[0])\n                min[0] = modelExtent[0];\n            if (modelExtent[1] < min[1])\n                min[1] = modelExtent[1];\n            if (modelExtent[2] < min[2])\n                min[2] = modelExtent[2];\n            if (modelExtent[3] > max[0])\n                max[0] = modelExtent[3];\n            if (modelExtent[4] > max[1])\n                max[1] = modelExtent[4];\n            if (modelExtent[5] > max[2])\n                max[2] = modelExtent[5];\n        });\n        return [min[0], min[1], min[2], max[0], max[1], max[2]];\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/dataHandling/BatchHandler.ts?");

/***/ }),

/***/ "./src/dataHandling/FileDropHandler.ts":
/*!*********************************************!*\
  !*** ./src/dataHandling/FileDropHandler.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileDropHandler: () => (/* binding */ FileDropHandler)\n/* harmony export */ });\n/* harmony import */ var _SmallLASLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SmallLASLoader */ \"./src/dataHandling/SmallLASLoader.ts\");\n/* harmony import */ var _BatchHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BatchHandler */ \"./src/dataHandling/BatchHandler.ts\");\n\n\nclass FileDropHandler {\n    /**\n     * The container element where the files can be dropped.\n     * @private\n     */\n    container;\n    /**\n     * The names of the loaded files. Duplicates are not allowed.\n     * @private\n     */\n    loadedFiles;\n    /**\n     * The file loader used to load the las files.\n     * @private\n     */\n    lasLoader;\n    device;\n    screen_size;\n    batchHandler;\n    constructor(container, device, uniformBuffer, depthBuffer, frameBuffer, compute_depth_shader_bindGroupLayouts, compute_shader_bindGroupLayouts, screenSize, maxBufferSize) {\n        this.container = container;\n        this.lasLoader = new _SmallLASLoader__WEBPACK_IMPORTED_MODULE_0__.SmallLASLoader();\n        this.loadedFiles = [];\n        this.device = device;\n        this.screen_size = screenSize;\n        this.batchHandler = new _BatchHandler__WEBPACK_IMPORTED_MODULE_1__.BatchHandler(device, uniformBuffer, depthBuffer, frameBuffer, compute_depth_shader_bindGroupLayouts, compute_shader_bindGroupLayouts, maxBufferSize, screenSize);\n        this.registerEvents();\n    }\n    /**\n     * @returns The batch Handler used to store the loaded points.\n     */\n    getBatchHandler() {\n        return this.batchHandler;\n    }\n    /**\n     * Registers the events for dragging files over the {@link container} and dropping them.\n     */\n    registerEvents() {\n        this.container.ondrop = (ev) => {\n            this.dropHandler(ev);\n        };\n        this.container.ondragover = (ev) => {\n            this.dragOverHandler(ev);\n        };\n    }\n    /**\n     * Handles the drop event. Uses the {@link loadDroppedFiles} method to load the dropped files.\n     * @param ev\n     */\n    dropHandler(ev) {\n        console.log(\"File(s) dropped\");\n        // Prevent default behavior (Prevent file from being opened)\n        ev.preventDefault();\n        if (!ev.dataTransfer) {\n            console.error(\"No data transfer\");\n            return;\n        }\n        const loadedFiles = [];\n        if (ev.dataTransfer.items) {\n            // Use DataTransferItemList interface to access the file(s)\n            [...ev.dataTransfer.items].forEach((item, i) => {\n                // If dropped items aren't files, reject them\n                if (item.kind === \"file\") {\n                    const file = item.getAsFile();\n                    console.log(`… file[${i}].name = ${file.name}`);\n                    loadedFiles.push(file);\n                }\n            });\n        }\n        else {\n            // Use DataTransfer interface to access the file(s)\n            [...ev.dataTransfer.files].forEach((file, i) => {\n                console.log(`… file[${i}].name = ${file.name}`);\n            });\n        }\n        this.loadDroppedFiles(loadedFiles);\n    }\n    /**\n     * Loads the dropped files. Checks if the file is already loaded and if it has the las ending.\n     * @param files\n     */\n    async loadDroppedFiles(files) {\n        for (let file of files) {\n            if (this.loadedFiles.includes(file.name)) {\n                console.log(\"Already loaded file\", file.name);\n                continue;\n            }\n            if (!this.hasLasEnding(file.name)) {\n                console.log(\"File does not have las ending\", file.name);\n                continue;\n            }\n            const header = await this.lasLoader.loadLasHeader(file);\n            console.log(\"loading las file\", file, header);\n            const points = await this.lasLoader.loadLasPointsAsBuffer(file, header);\n            console.log(\"got \", points, \" points from \", file.name);\n            this.batchHandler.add(points).then(() => console.log(\"Added points to buffer\"));\n            this.loadedFiles.push(file.name);\n        }\n    }\n    /**\n     * Checks if the file has one of the las endings found in {@link LAS_FILE_ENDINGS}.\n     * @param fileName the name of the file to check\n     * @returns true if the file has one of the las endings, false otherwise\n     */\n    hasLasEnding(fileName) {\n        for (let lasFileEnding of _SmallLASLoader__WEBPACK_IMPORTED_MODULE_0__.LAS_FILE_ENDINGS) {\n            if (fileName.endsWith(lasFileEnding)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Handles the drag over event. Prevents the default behavior.\n     * @param ev\n     */\n    dragOverHandler(ev) {\n        console.log(\"File(s) in drop zone\");\n        ev.preventDefault();\n    }\n    /**\n     * Returns the names of the loaded files.\n     * @returns {string[]} The names of the loaded files.\n     */\n    getFileNames() {\n        return this.loadedFiles;\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/dataHandling/FileDropHandler.ts?");

/***/ }),

/***/ "./src/dataHandling/SmallLASLoader.ts":
/*!********************************************!*\
  !*** ./src/dataHandling/SmallLASLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LAS_FILE_ENDINGS: () => (/* binding */ LAS_FILE_ENDINGS),\n/* harmony export */   SmallLASLoader: () => (/* binding */ SmallLASLoader)\n/* harmony export */ });\nconst LAS_FILE_ENDINGS = [\n    \".las\",\n    \".LAS\"\n];\n// Other fields:\n/*\nintensity: u_char;\nreturnNumber: u_char;\nnumberOfReturns: u_char;\nscanDirectionFlag: u_char;\nedgeOfFlightLine: u_char;\nclassification: u_char;\nscanAngleRank: u_char;\nuserData: u_char;\npointSourceID: u_short;\ngpsTime: double;\n */\nclass SmallLASLoader {\n    async loadLASHeader(file_path) {\n        const response = await fetch(file_path);\n        const buffer = await response.arrayBuffer();\n        const dataView = new DataView(buffer);\n        let header = {\n            versionMajor: dataView.getUint8(24),\n            versionMinor: dataView.getUint8(25),\n            headerSize: dataView.getUint16(94, true),\n            offsetToPointData: dataView.getUint32(96, true),\n            numberOfVariableLengthRecords: dataView.getUint32(100, true),\n            pointDataFormatID: dataView.getUint8(104),\n            pointDataRecordLength: dataView.getUint16(105, true),\n            xScaleFactor: dataView.getFloat64(131, true),\n            yScaleFactor: dataView.getFloat64(139, true),\n            zScaleFactor: dataView.getFloat64(147, true),\n            xOffset: dataView.getFloat64(155, true),\n            yOffset: dataView.getFloat64(163, true),\n            zOffset: dataView.getFloat64(171, true),\n            maxX: dataView.getFloat64(179, true),\n            minX: dataView.getFloat64(187, true),\n            maxY: dataView.getFloat64(195, true),\n            minY: dataView.getFloat64(203, true),\n            maxZ: dataView.getFloat64(211, true),\n            minZ: dataView.getFloat64(219, true),\n            // Set later\n            numberOfPointRecords: BigInt(0),\n            numberOfExtendedVariableLengthRecords: 0\n        };\n        if (header.versionMajor !== 1 || header.versionMinor <= 2) {\n            header.numberOfPointRecords = BigInt(dataView.getUint32(107, true));\n        }\n        else {\n            header.numberOfPointRecords = dataView.getBigUint64(247, true);\n            header.numberOfExtendedVariableLengthRecords = dataView.getUint32(243, true);\n        }\n        return header;\n    }\n    /**\n     * Reads the header information of a LAS file and returns it as a {@link LASHeader_small} object.\n     * @param file\n     */\n    async loadLasHeader(file) {\n        const buffer = await file.arrayBuffer();\n        const dataView = new DataView(buffer);\n        let header = {\n            versionMajor: dataView.getUint8(24),\n            versionMinor: dataView.getUint8(25),\n            headerSize: dataView.getUint16(94, true),\n            offsetToPointData: dataView.getUint32(96, true),\n            numberOfVariableLengthRecords: dataView.getUint32(100, true),\n            pointDataFormatID: dataView.getUint8(104),\n            pointDataRecordLength: dataView.getUint16(105, true),\n            xScaleFactor: dataView.getFloat64(131, true),\n            yScaleFactor: dataView.getFloat64(139, true),\n            zScaleFactor: dataView.getFloat64(147, true),\n            xOffset: dataView.getFloat64(155, true),\n            yOffset: dataView.getFloat64(163, true),\n            zOffset: dataView.getFloat64(171, true),\n            maxX: dataView.getFloat64(179, true),\n            minX: dataView.getFloat64(187, true),\n            maxY: dataView.getFloat64(195, true),\n            minY: dataView.getFloat64(203, true),\n            maxZ: dataView.getFloat64(211, true),\n            minZ: dataView.getFloat64(219, true),\n            // Set later\n            numberOfPointRecords: BigInt(0),\n            numberOfExtendedVariableLengthRecords: 0\n        };\n        if (header.versionMajor !== 1 || header.versionMinor <= 2) {\n            header.numberOfPointRecords = BigInt(dataView.getUint32(107, true));\n        }\n        else {\n            header.numberOfPointRecords = dataView.getBigUint64(247, true);\n            header.numberOfExtendedVariableLengthRecords = dataView.getUint32(243, true);\n        }\n        return header;\n    }\n    async loadLASPoints(file_path, header) {\n        const response = await fetch(file_path);\n        const buffer = await response.arrayBuffer();\n        const dataView = new DataView(buffer);\n        const numberOfPoints_int = Number(header.numberOfPointRecords);\n        const points = new Array(numberOfPoints_int);\n        for (let i = 0; i < numberOfPoints_int; i++) {\n            const offset = header.offsetToPointData + i * header.pointDataRecordLength;\n            points[i] = {\n                x: dataView.getInt32(offset + 0, true) * header.xScaleFactor + header.xOffset,\n                y: dataView.getInt32(offset + 8, true) * header.yScaleFactor + header.yOffset,\n                z: dataView.getInt32(offset + 16, true) * header.zScaleFactor + header.zOffset,\n                red: dataView.getUint16(offset + 28, true),\n                green: dataView.getUint16(offset + 30, true),\n                blue: dataView.getUint16(offset + 32, true),\n            };\n        }\n        return points;\n    }\n    /**\n     * Loads the points of a LAS file into a large {@link ArrayBuffer}.\n     * @param file_path the path of the file to load.\n     * @param header the header of the file. Needs to be loaded before.\n     * @param max_points the maximum number of points to load. Default is 1e12.\n     */\n    async loadLASPointsAsBuffer(file_path, header, max_points = 1e12) {\n        const response = await fetch(file_path);\n        const buffer = await response.arrayBuffer();\n        return this.loadLasPointsAsBufferHelper(buffer, header, max_points);\n    }\n    /**\n     * Loads the points of a LAS file into a large {@link ArrayBuffer}.\n     * @param file the file to load.\n     * @param header the header of the file. Needs to be loaded before.\n     * @param max_points the maximum number of points to load. Default is 1e12.\n     */\n    async loadLasPointsAsBuffer(file, header, max_points = 1e12) {\n        const buffer = await file.arrayBuffer();\n        return this.loadLasPointsAsBufferHelper(buffer, header, max_points);\n        // return this.loadLasPointsAsBufferHelperViaWorker(buffer, header, max_points);\n    }\n    /**\n     * Loads the points of a LAS file into a large {@link ArrayBuffer}.\n     * @param buffer the buffer of the file to load.\n     * @param header the header of the file. Needs to be loaded before.\n     * @param max_points the maximum number of points to load. Default is 1e12.\n     * @private\n     */\n    loadLasPointsAsBufferHelper(buffer, header, max_points = 1e12) {\n        const dataView = new DataView(buffer);\n        // The number of points skipped in each iteration. This can be done when working with very large models.\n        const skipper = 1;\n        // see https://github.com/m-schuetz/SimLOD/blob/eb9fde28b0f13c67eb03a919504840e46e940004/tools/las2simlod.mjs#L89-L93\n        let rgbOffset = 0;\n        if (header.pointDataFormatID === 2)\n            rgbOffset = 20;\n        if (header.pointDataFormatID === 3)\n            rgbOffset = 28;\n        if (header.pointDataFormatID === 5)\n            rgbOffset = 28;\n        if (header.pointDataFormatID === 7)\n            rgbOffset = 30;\n        console.log(\"rgbOffset according to header: \", rgbOffset);\n        const numberOfPoints_int = Number(header.numberOfPointRecords);\n        const pointBuffer = new ArrayBuffer(numberOfPoints_int * (16));\n        const pointView = new DataView(pointBuffer);\n        for (let i = 0; i < Math.min(numberOfPoints_int, max_points); i += skipper) {\n            this.handleOnePoint(header, dataView, pointView, i, skipper, rgbOffset);\n        }\n        return pointBuffer;\n    }\n    /**\n     * Handles one point of a LAS file and writes it into the point buffer.\n     * @param header the header of the LAS file.\n     * @param dataView A {@link DataView} into the LAS file to be loaded\n     * @param pointView A {@link DataView} into the point buffer to write the point into.\n     * @param i the index of the point to load.\n     * @param skipper the number of points skipped in each iteration.\n     * @param rgbOffset the offset of the RGB values in the LAS file.\n     */\n    async handleOnePoint(header, dataView, pointView, i, skipper, rgbOffset) {\n        const read_offset = header.offsetToPointData + i * header.pointDataRecordLength;\n        let x = dataView.getInt32(read_offset + 0, true) * header.xScaleFactor + header.xOffset;\n        let y = dataView.getInt32(read_offset + 4, true) * header.yScaleFactor + header.yOffset;\n        let z = dataView.getInt32(read_offset + 8, true) * header.zScaleFactor + header.zOffset;\n        let R = this.colorTo256(dataView.getUint16(read_offset + rgbOffset + 0, true));\n        let G = this.colorTo256(dataView.getUint16(read_offset + rgbOffset + 2, true));\n        let B = this.colorTo256(dataView.getUint16(read_offset + rgbOffset + 4, true));\n        let r = Math.floor(R > 255 ? R / 256 : R);\n        let g = Math.floor(G > 255 ? G / 256 : G);\n        let b = Math.floor(B > 255 ? B / 256 : B);\n        // write points into buffer\n        const writeOffset = (i / skipper) * 16;\n        pointView.setFloat32(writeOffset + 0, x, true);\n        pointView.setFloat32(writeOffset + 4, y, true);\n        pointView.setFloat32(writeOffset + 8, z, true);\n        pointView.setUint32(writeOffset + 12, r << 16 | g << 8 | b, true);\n    }\n    /**\n     * Loads the las points as a list of {@link Point} objects. Can be useful for debugging.\n     * @param file_path\n     * @param header\n     * @param max_points\n     * @deprecated\n     */\n    async loadLasPointsAsPoints(file_path, header, max_points = 1e12) {\n        const response = await fetch(file_path);\n        //\n        let rgbOffset = 0;\n        if (header.pointDataFormatID === 2)\n            rgbOffset = 20;\n        if (header.pointDataFormatID === 3)\n            rgbOffset = 28;\n        if (header.pointDataFormatID === 5)\n            rgbOffset = 28;\n        if (header.pointDataFormatID === 7)\n            rgbOffset = 30;\n        const numberOfPoints_int = Number(header.numberOfPointRecords);\n        const points = [];\n        const buffer = await response.arrayBuffer();\n        const dataView = new DataView(buffer);\n        // add points in corners for debugging\n        // points.push({x: 0, y: 0, z: 0, color: 0xff0000});\n        // points.push({x: 1, y: 0, z: 0, color: 0xff0000});\n        // points.push({x: 0, y: 1, z: 0, color: 0xff0000});\n        // points.push({x: 1, y: 1, z: 0, color: 0xff0000});\n        //\n        // points.push({x: 0, y: 0, z: 1, color: 0xff0000});\n        // points.push({x: 1, y: 0, z: 1, color: 0xff0000});\n        // points.push({x: 0, y: 1, z: 1, color: 0xff0000});\n        // points.push({x: 1, y: 1, z: 1, color: 0xff0000});\n        for (let i = 0; i < Math.min(numberOfPoints_int, max_points); i += 1) {\n            const offset = header.offsetToPointData + i * header.pointDataRecordLength;\n            let X = dataView.getInt32(offset + 0, true);\n            let Y = dataView.getInt32(offset + 4, true);\n            let Z = dataView.getInt32(offset + 8, true);\n            let x = X * header.xScaleFactor + header.xOffset;\n            let y = Y * header.yScaleFactor + header.yOffset;\n            let z = Z * header.zScaleFactor + header.zOffset;\n            // normalize to 0-1 box\n            x = (x - header.minX) / (header.maxX - header.minX);\n            y = (y - header.minY) / (header.maxY - header.minY);\n            z = (z - header.minZ) / (header.maxZ - header.minZ);\n            let R = dataView.getUint16(offset + rgbOffset + 0, true);\n            let G = dataView.getUint16(offset + rgbOffset + 2, true);\n            let B = dataView.getUint16(offset + rgbOffset + 4, true);\n            let r = Math.floor(R > 255 ? R / 256 : R);\n            let g = Math.floor(G > 255 ? G / 256 : G);\n            let b = Math.floor(B > 255 ? B / 256 : B);\n            // read into array\n            const point = {\n                x: x,\n                y: y,\n                z: z,\n                color: r << 16 | g << 8 | b\n            };\n            points.push(point);\n        }\n        return points;\n    }\n    /**\n     * Loads the las points using a web worker. This is not used in the current implementation. See LasLoaderWebWorker.worker.ts for the worker implementation.\n     * @param buffer\n     * @param header\n     * @param max_points\n     * @private\n     */\n    async loadLasPointsAsBufferHelperViaWorker(buffer, header, max_points = 1e12) {\n        return new Promise((resolve, reject) => {\n            const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"src_dataHandling_LasLoaderWebWorker_worker_ts\"), __webpack_require__.b));\n            // const worker = new LasWorker();\n            worker.onmessage = (event) => {\n                const { pointBuffer } = event.data;\n                console.log(\"Point Buffer received from worker:\", pointBuffer);\n                resolve(pointBuffer);\n            };\n            worker.onerror = (error) => {\n                console.error(\"Worker error:\", error);\n                reject(error);\n            };\n            // Post data to the worker\n            worker.postMessage({\n                buffer: buffer,\n                header: header,\n                max_points: max_points\n            }, [buffer]); // Transfer the buffer to avoid copying\n        });\n    }\n    /**\n     * Converts a color value to a 256 value. Sometimes the color values are stored as 16 bit values, then they are divided by 256.\n     * @param color the color value to convert.\n     * @private\n     */\n    colorTo256(color) {\n        return Math.floor(color > 255 ? color / 256 : color);\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/dataHandling/SmallLASLoader.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgpu-matrix */ \"./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js\");\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/util */ \"./src/utils/util.ts\");\n/* harmony import */ var _utils_quad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/quad */ \"./src/utils/quad.ts\");\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stats.js */ \"./node_modules/stats.js/build/stats.min.js\");\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(stats_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _types_c_equivalents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/c_equivalents */ \"./src/types/c_equivalents.ts\");\n/* harmony import */ var _dataHandling_FileDropHandler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataHandling/FileDropHandler */ \"./src/dataHandling/FileDropHandler.ts\");\n/* harmony import */ var dat_gui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n/* harmony import */ var _cameras_InputHandler_InertialTurntableCamera__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cameras/InputHandler-InertialTurntableCamera */ \"./src/cameras/InputHandler-InertialTurntableCamera.ts\");\n/* harmony import */ var _cameras_InertialTurntableCamera__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cameras/InertialTurntableCamera */ \"./src/cameras/InertialTurntableCamera.ts\");\n/* harmony import */ var _shaders_compute_multipleBuffers_wgsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./shaders/compute_multipleBuffers.wgsl */ \"./src/shaders/compute_multipleBuffers.wgsl\");\n/* harmony import */ var _shaders_compute_depth_shader_multipleBuffers_wgsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./shaders/compute_depth_shader_multipleBuffers.wgsl */ \"./src/shaders/compute_depth_shader_multipleBuffers.wgsl\");\n/* harmony import */ var _shaders_display_on_screan_wgsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./shaders/display_on_screan.wgsl */ \"./src/shaders/display_on_screan.wgsl\");\n/* harmony import */ var _utils_TimingHelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/TimingHelper */ \"./src/utils/TimingHelper.js\");\n\n\n\n\n\n\n\n\n\nconst canvas = document.getElementById(\"gfx-main\");\n// // set max size of canvas\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight;\nconst debug_div = document.getElementById(\"debug\");\n/**\n * The screen size used to calculate the aspect ratio of the camera.\n * This can change during runtime. The change is handled by the observer function {@link observer}.\n * @type {vec2.default}\n */\nlet screen_size = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec2.create(canvas.width, canvas.height);\nconst requestAdapterOptions = {\n    powerPreference: 'high-performance',\n};\nconst adapter = (await navigator.gpu.requestAdapter(requestAdapterOptions));\nif (!adapter) {\n    debug_div.innerText = \"WebGPU is supported but no adapter found!\";\n    throw Error(\"Couldn't request WebGPU adapter.\");\n}\nconst k1Gigabyte = 1024 * 1024 * 1024;\nconst device = (await adapter.requestDevice({\n    requiredLimits: {\n        maxBufferSize: 1 * k1Gigabyte,\n        // maxComputeWorkgroupStorageSize: 65536\n        maxStorageBufferBindingSize: 1 * k1Gigabyte,\n        // maxDynamicStorageBuffersPerPipelineLayout: 6,\n    },\n    requiredFeatures: ['timestamp-query'],\n}));\nconsole.log('Device: ', device);\nconst context = canvas.getContext(\"webgpu\");\nconst format = \"bgra8unorm\";\ncontext.configure({\n    device,\n    format,\n});\nconst maxWorkgroupsPerDimension = device.limits.maxComputeWorkgroupsPerDimension;\nconst maxStorageBufferBindingSize = device.limits.maxStorageBufferBindingSize;\n// Region Drag and Drop\n// Read out url parameter for buffer handler size.\nconst urlParams = new URLSearchParams(window.location.search);\nlet handlerSizeParameter = urlParams.get('bSize');\nlet BUFFER_HANDLER_SIZE = ((Math.pow(2, 20))) * _types_c_equivalents__WEBPACK_IMPORTED_MODULE_4__.SIZE_OF_POINT; // for storage 2^20 is about 1e6\nif (handlerSizeParameter) {\n    handlerSizeParameter = handlerSizeParameter.toLowerCase();\n    let decoded = 0;\n    // if just a number is given, it is interpreted as bytes\n    // if a number is given followed by k, m, g, it is interpreted as kilo, mega, giga bytes\n    if (handlerSizeParameter.endsWith(\"k\")) {\n        decoded = parseInt(handlerSizeParameter.slice(0, -1)) * Math.pow(2, 10);\n    }\n    else if (handlerSizeParameter.endsWith(\"m\")) {\n        decoded = parseInt(handlerSizeParameter.slice(0, -1)) * Math.pow(2, 20);\n    }\n    else if (handlerSizeParameter.endsWith(\"g\")) {\n        decoded = parseInt(handlerSizeParameter.slice(0, -1)) * Math.pow(2, 30);\n    }\n    else {\n        decoded = parseInt(handlerSizeParameter);\n    }\n    console.log(`size for buffer passed: ${decoded}`);\n    // Force adherence to the device limits and Size of Point\n    BUFFER_HANDLER_SIZE = Math.min(decoded, maxStorageBufferBindingSize);\n    BUFFER_HANDLER_SIZE = BUFFER_HANDLER_SIZE - (BUFFER_HANDLER_SIZE % _types_c_equivalents__WEBPACK_IMPORTED_MODULE_4__.SIZE_OF_POINT);\n}\nconsole.log(`BUFFER_HANDLER_SIZE: ${BUFFER_HANDLER_SIZE / Math.pow(2, 20)}M`);\nlet THREADS_PER_WORKGROUP = 64;\nlet handler_threads_per_workgroup = urlParams.get('tpw');\nif (handler_threads_per_workgroup) {\n    console.log(\"tpw: \", handler_threads_per_workgroup);\n    THREADS_PER_WORKGROUP = Math.max(Math.min(parseInt(handler_threads_per_workgroup), 256), 1);\n}\nconst container = document.getElementById(\"container\"); // The container element\n// Region GUI\nconst gui = new dat_gui__WEBPACK_IMPORTED_MODULE_6__.GUI();\n// GUI parameters\nconst params = {\n    renderQuality: 'auto',\n    show_debug_div: true,\n};\ngui.add(params, 'renderQuality', ['auto', 'coarse', \"medium\", \"fine\"]);\ngui.add(params, 'show_debug_div').onChange((value) => setDebugDivVisibility(value));\ngui.add({ view_to_model: resetViewport }, 'view_to_model').name(\"View to Model\");\n// This is done later down the line, I included it here to show that the functionality exists.\n// gui.add({run_benchmark: start_measurement()}, 'run_benchmark').name(\"Run Benchmark\");\n// Region vertex buffer\nconst quad_vertexBuffer = (0,_utils_quad__WEBPACK_IMPORTED_MODULE_2__.create_and_bind_quad_VertexBuffer)(device);\n// Region pipeline\n\nconst compute_pipelines = _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.create_compute_Pipelines_with_settings(device, _shaders_compute_multipleBuffers_wgsl__WEBPACK_IMPORTED_MODULE_9__[\"default\"], THREADS_PER_WORKGROUP, \"compute\");\n\nconst compute_depth_pipelines = _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.create_compute_Pipelines_with_settings(device, _shaders_compute_depth_shader_multipleBuffers_wgsl__WEBPACK_IMPORTED_MODULE_10__[\"default\"], THREADS_PER_WORKGROUP, \"compute depth\");\n\n\nconst display_shaderModule = device.createShaderModule({\n    label: \"display shader module\",\n    code: _shaders_display_on_screan_wgsl__WEBPACK_IMPORTED_MODULE_11__[\"default\"]\n});\nconst displayPipelineDescriptor = _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.createPipelineDescriptor_pos4_uv2(device, display_shaderModule, \"vs_main\", \"fs_main\", format);\ndisplayPipelineDescriptor.label = \"display pipeline descriptor\";\ndisplayPipelineDescriptor.primitive = { topology: 'triangle-strip' };\nconst displayPipeline = device.createRenderPipeline(displayPipelineDescriptor);\n// Region Framebuffer\nlet framebuffer = device.createBuffer({\n    label: \"framebuffer\",\n    size: canvas.width * canvas.height * 4 * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    mappedAtCreation: false,\n});\nlet depthBuffer = device.createBuffer({\n    label: \"depth buffer\",\n    size: canvas.width * canvas.height * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    mappedAtCreation: false,\n});\n// Region Debug Buffers\n/*\n// Some buffers for debugging, I will not remove them because they might be useful in the future.\nconst show_debug_buffers = false;\nconst debug_framebuffer = device.createBuffer({\n    label: \"debug framebuffer\",\n    size: canvas.width * canvas.height * 4 * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n});\n\nconst debug_depthBuffer = device.createBuffer({\n    label: \"debug depth buffer\",\n    size: canvas.width * canvas.height * Float32Array.BYTES_PER_ELEMENT,\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n});\n\nconst debug_uniformBuffer = device.createBuffer({\n    label: \"debug uniform buffer\",\n    size: 4 * Float32Array.BYTES_PER_ELEMENT    // canvas width, height, 2x padding\n        + 16 * Float32Array.BYTES_PER_ELEMENT   // mVP\n        + 4 * Float32Array.BYTES_PER_ELEMENT    // Batch origin\n        + 4 * Float32Array.BYTES_PER_ELEMENT    // Batch size\n        + 4 * Float32Array.BYTES_PER_ELEMENT,   // render type\n    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n});\n\n// const STAGING_BUFFER_SIZE = 1e6 * SIZE_OF_POINT;\nconst STAGING_BUFFER_SIZE = batchHandler.getBufferSize();\nconst stagingBuffer = device.createBuffer({\n    size: STAGING_BUFFER_SIZE,\n    usage: GPUBufferUsage.MAP_WRITE |\n        GPUBufferUsage.COPY_SRC,\n});\n */\n// End Region Debug Buffers\n// Region Uniform\nconst uniformBuffer = device.createBuffer({\n    label: \"uniform buffer\",\n    size: 4 * Float32Array.BYTES_PER_ELEMENT // canvas width, height, 2x padding\n        + 16 * Float32Array.BYTES_PER_ELEMENT // mVP\n        + 4 * Float32Array.BYTES_PER_ELEMENT // Batch origin\n        + 4 * Float32Array.BYTES_PER_ELEMENT // Batch size\n        + 4 * Float32Array.BYTES_PER_ELEMENT, // render type\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n});\n// Region BindGroup\nconst compute_depth_shader_bindGroupLayouts = compute_depth_pipelines.map(pipeline => pipeline.getBindGroupLayout(0));\ncompute_depth_shader_bindGroupLayouts.forEach((layout, index) => {\n    layout.label = \"compute depth pipeline layout\" +\n        (index === 0 ? \" coarse\" : index === 1 ? \" medium\" : \" fine\");\n});\nconst compute_shader_bindGroupLayouts = compute_pipelines.map(pipeline => pipeline.getBindGroupLayout(0));\ncompute_shader_bindGroupLayouts.forEach((layout, index) => {\n    layout.label = \"compute pipeline layout\" +\n        (index === 0 ? \" coarse\" : index === 1 ? \" medium\" : \" fine\");\n});\nconst display_pipelineLayout = displayPipeline.getBindGroupLayout(0);\ndisplay_pipelineLayout.label = \"display pipeline layout\";\nconst display_shader_bindGroup = device.createBindGroup({\n    label: \"display bind group\",\n    layout: display_pipelineLayout,\n    entries: [\n        {\n            binding: 0,\n            resource: {\n                buffer: uniformBuffer,\n            }\n        },\n        {\n            binding: 1,\n            resource: {\n                buffer: framebuffer,\n            }\n        },\n    ]\n});\n// Region RenderPassDescriptor\nconst display_renderPassDescriptor = _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.create_display_RenderPassDescriptor(context, [0, 0, 0, 1]);\n// Region frame\n/**\n * Observer function to handle the resizing of the canvas.\n * The observer function is called when the canvas is resized.\n * The size of the canvas is stored in the {@link screen_size} variable.\n */\nconst observer = new ResizeObserver(entries => {\n    for (const entry of entries) {\n        const width = entry.contentBoxSize[0].inlineSize;\n        const height = entry.contentBoxSize[0].blockSize;\n        // clamp the size to the device limits\n        canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));\n        canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));\n        // update the aspect ratio and screen size for rendering\n        aspect = canvas.width / canvas.height;\n        screen_size[0] = canvas.width;\n        screen_size[1] = canvas.height;\n        // update the camera aspect\n        camera.resize(aspect);\n    }\n});\nobserver.observe(canvas);\n/**\n * The aspect ratio of the camera.\n * Calculated using the width and height of the canvas initially, is updated when the canvas is resized.\n */\nlet aspect = canvas.width / canvas.height;\nconsole.log('aspect: ', aspect);\n// Region setup camera and handlers\n/**\n * The camera used to view the scene.\n * The behaviour of the camera can be easily changed by writing a new camera class.\n */\nconst camera = new _cameras_InertialTurntableCamera__WEBPACK_IMPORTED_MODULE_8__.InertialTurntableCamera(Math.PI / 4, aspect, 1, 100);\nconst inputHandler = new _cameras_InputHandler_InertialTurntableCamera__WEBPACK_IMPORTED_MODULE_7__.InputHandlerInertialTurntableCamera(canvas, camera);\ninputHandler.registerInputHandlers();\nconst modelMatrix = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.identity();\nconst viewProjMatrix = Float64Array.from(webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create());\nconst mVP = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.create();\nconst fileDropHandler = new _dataHandling_FileDropHandler__WEBPACK_IMPORTED_MODULE_5__.FileDropHandler(container, device, uniformBuffer, depthBuffer, framebuffer, compute_depth_shader_bindGroupLayouts, compute_shader_bindGroupLayouts, screen_size, BUFFER_HANDLER_SIZE);\nlet batchHandler = fileDropHandler.getBatchHandler();\n// Region setup stats\nconst stats = new (stats_js__WEBPACK_IMPORTED_MODULE_3___default())();\ndocument.body.appendChild(stats.dom);\nconst gpuTimePanel = stats.addPanel(new stats_js__WEBPACK_IMPORTED_MODULE_3__.Panel('ms GPU', '#ff8', '#221'));\nstats.showPanel(0);\n/**\n * Reset the viewport so that the model is in the center of the view.\n * This function is called when the user presses the \"view to model\" button.\n */\nfunction resetViewport() {\n    // figure out extent of the model\n    const modelExtent = batchHandler.getTotalModelExtent();\n    console.log(`model extent: ${modelExtent}`);\n    // set camera so that the model is in the center of the view\n    let modelCenter = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create((modelExtent[0] + modelExtent[3]) / 2, (modelExtent[1] + modelExtent[4]) / 2, (modelExtent[2] + modelExtent[5]) / 2);\n    console.log(`model center: ${modelCenter}`);\n    // set camera so that the model is in the view\n    const modelSize = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.vec3.create(modelExtent[3] - modelExtent[0], modelExtent[4] - modelExtent[1], modelExtent[5] - modelExtent[2]);\n    const modelSizeMax = Math.max(modelSize[0], modelSize[1], modelSize[2]);\n    const modelSizeMin = Math.min(modelSize[0], modelSize[1], modelSize[2]);\n    console.log(`modelSizeMax: ${modelSizeMax}, modelSizeMin: ${modelSizeMin}`);\n    // const distance = modelSizeMax / Math.tan(camera.fov / 2);\n    const fovX = camera.fov * camera.aspect;\n    // technically it would be correct to divide modelSizeMax by 2 because the calculation uses a right angle triangle,\n    // however it looks better if the model is in the center of the view occupying half of the view instead of the whole view.\n    const distance = (modelSizeMax / 1) / Math.tan(fovX / 2);\n    console.log(`Center: ${modelCenter}, Distance: ${distance}`);\n    camera.reset();\n    camera.tick({\n        center: modelCenter,\n        // distance: distance,\n    });\n    camera.tick({\n        distance: distance,\n    });\n    console.log(\"camera: \", camera.getParams());\n}\n// Setup Timing\nconst timingHelper = new _utils_TimingHelper__WEBPACK_IMPORTED_MODULE_12__[\"default\"](device);\nlet is_timing = false;\n// Duration of test in ms\nconst time_for = 5 * 1000;\n// Duration the test has been run in ms\nlet timed_for = 0;\nconst gpu_times = [];\nlet gpu_time_this_frame = 0;\nconst total_frame_times = [];\ngui.add({ run_benchmark: start_measurement }, 'run_benchmark').name(\"Run Benchmark\");\n/**\n * Starts the measurement of the GPU time.\n * This function is called when the user presses the \"start measurement\" button.\n */\nasync function start_measurement() {\n    if (is_timing) {\n        console.log(\"Already measuring\");\n        return;\n    }\n    console.log(\"Starting measurement for \" + time_for + \"ms\");\n    is_timing = true;\n    setTimeout(stop_measurement, time_for);\n}\n/**\n * Retrieves measured information and calculates averages.\n */\nfunction stop_measurement() {\n    let avg_gpu_times = 0;\n    gpu_times.forEach(gpu => {\n        avg_gpu_times += gpu;\n    });\n    avg_gpu_times /= gpu_times.length;\n    let avg_frame_times = 0;\n    total_frame_times.forEach(frame => {\n        avg_frame_times += frame;\n    });\n    avg_frame_times /= total_frame_times.length;\n    const avg_fps = (total_frame_times.length / timed_for) * 1000;\n    console.log(`\n    Average GPU time: ${avg_gpu_times} ms\n    Average Frame time: ${avg_frame_times} ms\n    Average FPS: ${avg_fps}\n    `);\n    is_timing = false;\n    download_benchmark_result(`bSize-${BUFFER_HANDLER_SIZE}_TpW-${THREADS_PER_WORKGROUP}_model-${fileDropHandler.getFileNames()[0]}`, gpu_times, total_frame_times);\n}\n/**\n * Downloads the benchmark results as a csv file.\n * @param name The name of the benchmark\n * @param gpus an array of GPU times in ms\n * @param totals an array of total frame times in ms\n */\nfunction download_benchmark_result(name, gpus, totals) {\n    // const data = `GPU Times: ${gpus.join(\", \")}\\nTotal Frame Times: ${totals.join(\", \")}`;\n    const data = `GPU Times (ms),Total Frame Times (ms)\\n` +\n        gpus.map((gpu, index) => `${gpu},${totals[index]}`).join(\"\\n\");\n    const blob = new Blob([data], { type: \"text/plain\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = name + \".csv\";\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n}\nconst initial_depthBuffer = new Float32Array(canvas.width * canvas.height).fill(0xFFFFFFFF);\n// device.queue.writeBuffer(depthBuffer, 0, initial_depthBuffer.buffer, 0, initial_depthBuffer.byteLength);\n// unmap depth buffer\ndepthBuffer.unmap();\nlet numberOfPoints = 0;\n/**\n * The main function that generates the frame. This function is called recursively using requestAnimationFrame.\n */\nasync function generateFrame() {\n    const start_time = performance.now();\n    // update stats\n    stats.begin();\n    // update camera\n    camera.tick();\n    let commandEncoder = device.createCommandEncoder();\n    // get mVP matrix\n    const proj64 = Float64Array.from(camera.getProjectionMatrix());\n    const view64 = Float64Array.from(camera.getViewMatrix());\n    _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.multiplyMat4dTof64(proj64, view64, viewProjMatrix);\n    // Util.multiplyMat4dTof32(proj64, view64, mVP);\n    // reset depth buffer\n    device.queue.writeBuffer(depthBuffer, 0, initial_depthBuffer.buffer, 0, initial_depthBuffer.byteLength);\n    const upload_waiter = batchHandler.writeOneBufferToGPU();\n    const batches_shown = [];\n    const batches_renderType = [];\n    // Workgroup initial values for later\n    let xWorkGroups = 1;\n    let yWorkGroups = 1;\n    let zWorkGroups = 1;\n    // go through all the batches and render visible ones\n    for (const batch of batchHandler.getBatches()) {\n        if (!batch.isWrittenToGPU()) {\n            continue;\n        }\n        if (!batch.isInFrustum(Float32Array.from(viewProjMatrix))) {\n            // console.log(`batch ${batch.getID()} not on screen`);\n            batches_renderType.push(-1);\n            continue;\n        }\n        else {\n            batches_shown.push(batch.getID());\n        }\n        // Region accuracy Level\n        let accuracy_level = 2;\n        switch (params.renderQuality) {\n            case \"auto\":\n                accuracy_level = batch.getAccuracyLevel(mVP);\n                break;\n            case \"coarse\":\n                accuracy_level = 0;\n                break;\n            case \"medium\":\n                accuracy_level = 1;\n                break;\n            case \"fine\":\n                accuracy_level = 2;\n                break;\n        }\n        batches_renderType.push(accuracy_level);\n        const compute_depth_pipeline = compute_depth_pipelines[accuracy_level];\n        // Region Uniform\n        webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.translate(webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.identity(), batch.getOrigin(), modelMatrix);\n        _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.multiplyMat4dTof32(viewProjMatrix, modelMatrix, mVP);\n        // building the uniform buffer data\n        const uniform_data = new Float32Array([\n            screen_size[0], screen_size[1], 0, 0, // padding\n            ...mVP,\n            // ...batch.getOrigin(), 0,\n            0, 0, 0, 0,\n            ...batch.getBoxSize(), 0,\n            accuracy_level, THREADS_PER_WORKGROUP, 0, 0,\n        ]);\n        device.queue.writeBuffer(uniformBuffer, 0, uniform_data.buffer, uniform_data.byteOffset, uniform_data.byteLength);\n        let nr_pointsInCurrentBuffer = batch.filledSize();\n        // Region Workgroups\n        const totalWorkGroups = Math.ceil(nr_pointsInCurrentBuffer / THREADS_PER_WORKGROUP);\n        if (totalWorkGroups <= device.limits.maxComputeWorkgroupsPerDimension) {\n            xWorkGroups = totalWorkGroups;\n            // } else if (totalWorkGroups <= Math.pow(device.limits.maxComputeWorkgroupsPerDimension, 2)) {\n            //     yWorkGroups = Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n            //     xWorkGroups = Math.ceil(totalWorkGroups / yWorkGroups);\n        }\n        else if (totalWorkGroups <= Math.pow(device.limits.maxComputeWorkgroupsPerDimension, 3)) {\n            zWorkGroups = Math.ceil(totalWorkGroups / (device.limits.maxComputeWorkgroupsPerDimension * device.limits.maxComputeWorkgroupsPerDimension));\n            yWorkGroups = Math.ceil(totalWorkGroups / (device.limits.maxComputeWorkgroupsPerDimension * zWorkGroups));\n            xWorkGroups = Math.ceil(totalWorkGroups / (yWorkGroups * zWorkGroups));\n        }\n        const compute_depth_shader_bindGroup = batch.get_depth_bindGroup(accuracy_level);\n        // Region Compute Depth Pass\n        // const compute_depth_pass = commandEncoder.beginComputePass();\n        const compute_depth_pass = timingHelper.beginComputePass(commandEncoder);\n        compute_depth_pass.setPipeline(compute_depth_pipeline);\n        compute_depth_pass.setBindGroup(0, compute_depth_shader_bindGroup);\n        compute_depth_pass.dispatchWorkgroups(Math.max(1, xWorkGroups), Math.max(1, yWorkGroups), Math.max(1, zWorkGroups));\n        compute_depth_pass.end();\n        device.queue.submit([commandEncoder.finish()]);\n        commandEncoder = device.createCommandEncoder();\n        /*\n        if (is_timing) {\n            timingHelper.getResult().then(gpuTime => {\n                // gpu_times.push(gpuTime / 1000);\n                gpu_time_this_frame += gpuTime / 1000;\n            });\n        } else {\n            timingHelper.getResult().then(gpuTime => {\n            })\n        }\n         */\n        timingHelper.getResult().then(gpuTime => gpu_time_this_frame += gpuTime);\n        // numberOfPoints += nr_pointsInCurrentBuffer;\n    }\n    // Workgroup initial values for later\n    xWorkGroups = 1;\n    yWorkGroups = 1;\n    zWorkGroups = 1;\n    // go through all the batches and render visible ones\n    for (const batch of batchHandler.getBatches()) {\n        if (!batch.isWrittenToGPU()) {\n            continue;\n        }\n        if (!batch.isInFrustum(mVP))\n            continue;\n        // Region accuracy Level\n        let accuracy_level = 2;\n        switch (params.renderQuality) {\n            case \"auto\":\n                accuracy_level = batch.getAccuracyLevel(mVP);\n                break;\n            case \"coarse\":\n                accuracy_level = 0;\n                break;\n            case \"medium\":\n                accuracy_level = 1;\n                break;\n            case \"fine\":\n                accuracy_level = 2;\n                break;\n        }\n        // batches_renderType.push(accuracy_level);\n        const computePipeline = compute_pipelines[accuracy_level];\n        // Region Uniform\n        webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.translate(webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.identity(), batch.getOrigin(), modelMatrix);\n        _utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.multiplyMat4dTof32(viewProjMatrix, modelMatrix, mVP);\n        // building the uniform buffer data\n        const uniform_data = new Float32Array([\n            screen_size[0], screen_size[1], 0, 0, // padding\n            ...mVP,\n            // ...batch.getOrigin(), 0,\n            0, 0, 0, 0,\n            ...batch.getBoxSize(), 0,\n            accuracy_level, THREADS_PER_WORKGROUP, 0, 0,\n        ]);\n        device.queue.writeBuffer(uniformBuffer, 0, uniform_data.buffer, uniform_data.byteOffset, uniform_data.byteLength);\n        let nr_pointsInCurrentBuffer = batch.filledSize();\n        // Region Workgroups\n        const totalWorkGroups = Math.ceil(nr_pointsInCurrentBuffer / THREADS_PER_WORKGROUP);\n        if (totalWorkGroups <= device.limits.maxComputeWorkgroupsPerDimension) {\n            xWorkGroups = totalWorkGroups;\n            // } else if (totalWorkGroups <= Math.pow(device.limits.maxComputeWorkgroupsPerDimension, 2)) {\n            //     yWorkGroups = Math.ceil(totalWorkGroups / device.limits.maxComputeWorkgroupsPerDimension);\n            //     xWorkGroups = Math.ceil(totalWorkGroups / yWorkGroups);\n        }\n        else if (totalWorkGroups <= Math.pow(device.limits.maxComputeWorkgroupsPerDimension, 3)) {\n            zWorkGroups = Math.ceil(totalWorkGroups / (device.limits.maxComputeWorkgroupsPerDimension * device.limits.maxComputeWorkgroupsPerDimension));\n            yWorkGroups = Math.ceil(totalWorkGroups / (device.limits.maxComputeWorkgroupsPerDimension * zWorkGroups));\n            xWorkGroups = Math.ceil(totalWorkGroups / (yWorkGroups * zWorkGroups));\n        }\n        const compute_shader_bindGroup = batch.get_compute_bindGroup(accuracy_level);\n        // Region Compute Pass\n        // const computePass = commandEncoder.beginComputePass();\n        const computePass = timingHelper.beginComputePass(commandEncoder);\n        computePass.setPipeline(computePipeline);\n        computePass.setBindGroup(0, compute_shader_bindGroup);\n        computePass.dispatchWorkgroups(Math.max(1, xWorkGroups), Math.max(1, yWorkGroups), Math.max(1, zWorkGroups));\n        computePass.end();\n        device.queue.submit([commandEncoder.finish()]);\n        commandEncoder = device.createCommandEncoder();\n        /*\n        if (is_timing) {\n            timingHelper.getResult().then(gpuTime => {\n                // gpu_times.push(gpuTime / 1000);\n                gpu_time_this_frame += gpuTime / 1000;\n            });\n        } else {\n            timingHelper.getResult().then(gpuTime => {\n            })\n        }\n         */\n        timingHelper.getResult().then(gpuTime => gpu_time_this_frame += gpuTime);\n        numberOfPoints += nr_pointsInCurrentBuffer;\n    }\n    gpu_time_this_frame /= 1e6; // convert to ms\n    if (is_timing) {\n        gpu_times.push(gpu_time_this_frame);\n    }\n    // gpu_time_this_frame = 0;\n    const batches_not_shown = [];\n    for (let i = 0; i < batchHandler.numberOfBuffers(); i++) {\n        if (!(i in batches_shown)) {\n            batches_not_shown.push(i);\n        }\n    }\n    if (debug_div.checkVisibility()) {\n        debug_div.innerText = `Number of points: ${_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.segmentNumber(numberOfPoints)},\n        Number of points per batch: ${_utils_util__WEBPACK_IMPORTED_MODULE_1__.Util.segmentNumber(batchHandler.getBatch(0).getBatchSize())},\n        Number of batches: ${batchHandler.numberOfBuffers()},\n        Batches shown: ${batches_shown.join(\"\\t\")},\n        Batches not shown: ${batches_not_shown.join(\"\\t\")},\n        Batches render type: ${batches_renderType.join(\"\\t\")},\n        TpW: ${THREADS_PER_WORKGROUP},\n        Workgroups: ${xWorkGroups} x ${yWorkGroups} x ${zWorkGroups},\n        vp matrix: \n        ${formatF32ArrayAsMatrix(camera.getViewMatrix())}\n        mvp matrix: \n        ${formatF32ArrayAsMatrix(mVP)},\n        `;\n    }\n    // reset viewport\n    display_renderPassDescriptor.colorAttachments[0]\n        .view = context.getCurrentTexture().createView();\n    // Region Display Pass\n    const displayPass = commandEncoder.beginRenderPass(display_renderPassDescriptor);\n    displayPass.setPipeline(displayPipeline);\n    displayPass.setBindGroup(0, display_shader_bindGroup);\n    displayPass.setVertexBuffer(0, quad_vertexBuffer);\n    displayPass.draw(4, 1, 0, 0);\n    displayPass.end();\n    // unmap framebuffer\n    commandEncoder.clearBuffer(framebuffer, 0, framebuffer.size);\n    framebuffer.unmap();\n    device.queue.submit([commandEncoder.finish()]); // submit\n    numberOfPoints = 0;\n    await upload_waiter;\n    // incorporate gpu time measurement\n    gpuTimePanel.update(gpu_time_this_frame, 10);\n    gpu_time_this_frame = 0;\n    stats.end();\n    // time\n    const end_time = performance.now();\n    if (is_timing) {\n        const time_diff = end_time - start_time;\n        total_frame_times.push(time_diff);\n        timed_for += time_diff;\n        if (timed_for > time_for) {\n            stop_measurement();\n        }\n    }\n    requestAnimationFrame(generateFrame);\n}\nrequestAnimationFrame(generateFrame);\nfunction formatF32ArrayAsMatrix(float32Array) {\n    const helper = webgpu_matrix__WEBPACK_IMPORTED_MODULE_0__.mat4.transpose(float32Array);\n    let string = \"\";\n    for (let i = 0; i < float32Array.length; i++) {\n        string += helper[i].toFixed(2) + \",\\t   \";\n        if ((i + 1) % 4 == 0 && i != 0) {\n            string += \"\\n\";\n        }\n    }\n    return string;\n}\nfunction setDebugDivVisibility(visible) {\n    debug_div.style.display = visible ? \"block\" : \"none\";\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://point_cloud_renderer/./src/main.ts?");

/***/ }),

/***/ "./src/types/c_equivalents.ts":
/*!************************************!*\
  !*** ./src/types/c_equivalents.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIZE_OF_POINT: () => (/* binding */ SIZE_OF_POINT)\n/* harmony export */ });\n/**\n * This file contains the equivalent types in C for the types used in the project.\n */\n/**\n * The size of a point in bytes. It is equal to 4 * 4 bytes.\n */\nconst SIZE_OF_POINT = 4 * Float32Array.BYTES_PER_ELEMENT; // 4 * 4 bytes\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/types/c_equivalents.ts?");

/***/ }),

/***/ "./src/utils/quad.ts":
/*!***************************!*\
  !*** ./src/utils/quad.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create_and_bind_quad_VertexBuffer: () => (/* binding */ create_and_bind_quad_VertexBuffer),\n/* harmony export */   quad_vertex_array: () => (/* binding */ quad_vertex_array)\n/* harmony export */ });\n/**\n * The vertex array for the full-screen quad.\n */\nconst quad_vertex_array = new Float32Array([\n    -1, -1, 0, 1, 0, 0,\n    1, -1, 0, 1, 1, 0,\n    -1, 1, 0, 1, 0, 1,\n    1, 1, 0, 1, 1, 1,\n]);\nconst quad_vertex_size = 6 * 4;\nconst quad_position_offset = 0;\nconst quad_uv_offset = 4 * 4;\nconst quad_vertex_count = 4;\n/**\n * Create and bind the vertex buffer for the full-screen quad. Load the vertex array into the buffer.\n * @param device The GPU device.\n */\nfunction create_and_bind_quad_VertexBuffer(device) {\n    const quad_vertexBuffer = device.createBuffer({\n        label: \"quad vertex buffer\",\n        size: quad_vertex_array.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n        mappedAtCreation: true,\n    });\n    new Float32Array(quad_vertexBuffer.getMappedRange()).set(quad_vertex_array);\n    quad_vertexBuffer.unmap();\n    return quad_vertexBuffer;\n}\n\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/utils/quad.ts?");

/***/ }),

/***/ "./src/utils/util.ts":
/*!***************************!*\
  !*** ./src/utils/util.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Util: () => (/* binding */ Util)\n/* harmony export */ });\nclass Util {\n    /**\n     * Create a {@link GPURenderPipelineDescriptor} for a pipeline.\n     *\n     * The vertex shader must have a position attribute and an uv attribute.\n     *\n     * The fragment shader must have a single output target.\n     *\n     *\n     * @param device The GPU device.\n     * @param shader_module The shader module for the vertex and fragment shader.\n     * @param vs_entry_point The entry point for the vertex shader.\n     * @param fs_entry_point The entry point for the fragment shader.\n     * @param format The format of the output target.\n     */\n    static createPipelineDescriptor_pos4_uv2(device, shader_module, vs_entry_point, fs_entry_point, format) {\n        return {\n            layout: 'auto',\n            vertex: {\n                module: shader_module,\n                entryPoint: vs_entry_point,\n                buffers: [\n                    {\n                        arrayStride: 6 * 4,\n                        attributes: [\n                            {\n                                format: 'float32x4',\n                                offset: 0,\n                                shaderLocation: 0\n                            },\n                            {\n                                format: 'float32x2',\n                                shaderLocation: 1,\n                                offset: 4 * 4\n                            }\n                        ]\n                    }\n                ]\n            },\n            fragment: {\n                module: shader_module,\n                entryPoint: fs_entry_point,\n                targets: [{ format: format }],\n            },\n        };\n    }\n    ;\n    /**\n     * Create a {@link GPUBindGroupLayout} for a bind group using an array of {@link GPUBuffer}s.\n     * @param device The GPU device.\n     * @param layout The layout of the bind group.\n     * @param buffers The buffers to bind.\n     * @returns {GPUBindGroupLayout} The bind group layout.\n     */\n    static createBindGroup(device, layout, buffers) {\n        const entries = buffers.map((buffer, i) => {\n            return {\n                binding: i,\n                resource: {\n                    buffer: buffer\n                }\n            };\n        });\n        return device.createBindGroup({\n            layout: layout,\n            entries: entries\n        });\n    }\n    ;\n    /**\n     * Creates a {@link GPURenderPassDescriptor} for the render pass that clears the color attachment.\n     * @param context The canvas context.\n     * @param clearValue The clear value for the color attachment.\n     */\n    static create_display_RenderPassDescriptor(context, clearValue) {\n        return {\n            label: \"display render pass\",\n            colorAttachments: [\n                {\n                    storeOp: 'store',\n                    loadOp: 'clear',\n                    view: context.getCurrentTexture().createView(),\n                    clearValue: clearValue,\n                }\n            ]\n        };\n    }\n    ;\n    /**\n     * Create three gpu compute pipelines for the coarse, medium and fine buffers.\n     * @param device The GPU device to create the pipelines on.\n     * @param code The code of the shader as a string.\n     * @param workgroup_size The workgroup size for the shader.\n     * @param label The label for the pipelines. This will be appended to and used to label the shader modules as well. Name this only something like \"compute\" without appending \"pipeline\" or \"shader module\" yourself.\n     */\n    static create_compute_Pipelines_with_settings(device, code, workgroup_size, label) {\n        const shader_modules = [\n            Util.create_shaderModule_with_settings(device, code, \"C\", workgroup_size, label + \" shader module coarse\"),\n            Util.create_shaderModule_with_settings(device, code, \"M\", workgroup_size, label + \" shader module medium\"),\n            Util.create_shaderModule_with_settings(device, code, \"F\", workgroup_size, label + \" shader module fine\")\n        ];\n        const descriptor = {\n            layout: \"auto\",\n            compute: {\n                module: null,\n                entryPoint: \"main\"\n            }\n        };\n        return shader_modules.map((module, index) => {\n            descriptor.compute.module = module;\n            descriptor.label = label + \" pipeline \" + (index === 0 ? \"coarse\" : index === 1 ? \"medium\" : \"fine\");\n            return device.createComputePipeline(descriptor);\n        });\n    }\n    /**\n     * Create a shader module from the shader code but only keep the buffers and functions for the coarse pass.\n     * @param device The GPU device to create the shader module on.\n     * @param code The code of the shader as a string.\n     * @param type The type of the shader (e.g. \"C\" for coarse, \"M\" for medium, \"F\" for fine).\n     * @param workgroup_size The workgroup size for the shader.\n     * @param label The optional label for the shader module.\n     */\n    static create_shaderModule_with_settings(device, code, type, workgroup_size, label) {\n        const stripped_code = Util.strip_shaderCode(code, type);\n        const final_code = Util.change_shader_workgroup_size(stripped_code, workgroup_size);\n        const shader_module_descriptor = {\n            code: final_code\n        };\n        if (label)\n            shader_module_descriptor.label = label;\n        return device.createShaderModule(shader_module_descriptor);\n    }\n    static change_shader_workgroup_size(code, workgroup_size) {\n        const lines = code.split('\\n');\n        for (let i = 0; i < lines.length; i++) {\n            if (lines[i].trim().startsWith(\"@compute\")) {\n                // match a number and replace it with the workgroup size\n                lines[i] = lines[i].replace(/\\d+/, workgroup_size.toString());\n            }\n        }\n        return lines.join('\\n');\n    }\n    /**\n     * Removes the unnecessary buffers and functions from the shader code based on the type.\n     * @param code the shader code to strip down.\n     * @param type the type of shader to keep. The others will be removed.\n     */\n    static strip_shaderCode(code, type) {\n        const lines = code.split('\\n');\n        let result = \"\";\n        let keep = false;\n        const all_types = [\"C\", \"M\", \"F\"];\n        const include_lowers = all_types.slice(0, all_types.indexOf(type) + 1);\n        // Stripping single lines\n        for (let i = 0; i < lines.length; i++) {\n            const trimmed = lines[i].trim();\n            if (trimmed.startsWith(\"/*fn_\") && !trimmed.startsWith(\"/*fn_\" + type)) {\n                while (!lines[i].startsWith(\"/*fn_end*/\")) {\n                    i++;\n                }\n                i++;\n            }\n            else if (trimmed.startsWith(\"/*\")) {\n                // keep = trimmed.startsWith(\"/*\" + type);\n                const c = trimmed.charAt(2);\n                if (include_lowers.includes(c))\n                    result += lines[i] + \"\\n\";\n            }\n            else if (i < lines.length)\n                result += lines[i] + \"\\n\";\n            // keep = true;\n            // if (keep && i < lines.length) {\n            //     result += lines[i] + '\\n';\n            // }\n        }\n        return result;\n    }\n    /**\n     * Add a number separator every 3 digits.\n     * @param n The number to add separators to.\n     * @returns {string} The number with separators.\n     */\n    static segmentNumber(n) {\n        const s = n.toString();\n        let result = \"\";\n        let count = 1;\n        for (let i = s.length; i > 0; i--) {\n            result = s.at(i - 1) + result;\n            if (count === 3) {\n                result = \" \" + result;\n                count = 0;\n            }\n            count++;\n        }\n        return result;\n    }\n    static createRandomPoints(n) {\n        const points = [];\n        const white = 0xffffff;\n        // (255, 255, 255) = white\n        console.log('white: ', white);\n        for (let i = 0; i < n; i++) {\n            points.push({\n                x: Util.randomNumberBetween(0, 1),\n                y: Util.randomNumberBetween(0, 1),\n                z: Util.randomNumberBetween(0, 1),\n                color: ((Math.random() * 0xff) << 16)\n                    + ((Math.random() * 0xff) << 8)\n                    + (Math.random() * 0xff << 0),\n                // color: 0x0f0f0f,\n            });\n        }\n        return points;\n    }\n    // Create points in a line (x-axis)\n    static createDepthBufferTest(n) {\n        const points = [];\n        for (let i = 0; i < n; i++) {\n            points.push({\n                x: 0,\n                y: i / n * 100,\n                z: 0,\n                color: 0x0f0f0f,\n            });\n        }\n        return points;\n    }\n    /**\n     * Generate a random number between min and max.\n     * @param min The minimum value.\n     * @param max The maximum value.\n     */\n    static randomNumberBetween(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    /**\n     * Convert an array of {@link Point}s to an ArrayBuffer.\n     * @param points the array of {@link Point}s to convert.\n     */\n    static convertPointsToArrayBuffer(points) {\n        const arr = new ArrayBuffer(points.length * 16);\n        const view = new DataView(arr);\n        for (let i = 0; i < points.length; i++) {\n            const offset = i * 16;\n            view.setFloat32(offset + 0, points[i].x, true);\n            view.setFloat32(offset + 4, points[i].y, true);\n            view.setFloat32(offset + 8, points[i].z, true);\n            view.setUint32(offset + 12, points[i].color, true);\n        }\n        return arr;\n    }\n    /**\n     * Multiplies two 4x4 matrices represented as Float64Arrays and stores the result in a Float32Array.\n     * @param a Float64Array representing the first matrix.\n     * @param b Float64Array representing the second matrix.\n     * @param dest Float32Array where the result will be stored.\n     */\n    static multiplyMat4dTof32(a, b, dest) {\n        for (let row = 0; row < 4; ++row) {\n            for (let col = 0; col < 4; ++col) {\n                let sum = 0;\n                for (let i = 0; i < 4; ++i) {\n                    sum += a[row + i * 4] * b[i + col * 4];\n                }\n                dest[row + col * 4] = sum;\n            }\n        }\n    }\n    static multiplyMat4dTof64(a, b, dest) {\n        for (let row = 0; row < 4; ++row) {\n            for (let col = 0; col < 4; ++col) {\n                let sum = 0;\n                for (let i = 0; i < 4; ++i) {\n                    sum += a[row + i * 4] * b[i + col * 4];\n                }\n                dest[row + col * 4] = sum;\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://point_cloud_renderer/./src/utils/util.ts?");

/***/ }),

/***/ "./src/shaders/compute_depth_shader_multipleBuffers.wgsl":
/*!***************************************************************!*\
  !*** ./src/shaders/compute_depth_shader_multipleBuffers.wgsl ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct Uniforms {\\n    canvas_size: vec4<f32>,\\n    mvp: mat4x4<f32>,\\n    origin: vec4<f32>,\\n    size: vec4<f32>,\\n    renderingInfo: vec4<f32>,\\n};\\n\\n\\n//struct Points {\\n//    coarse: array<u32>, // each u32 element has the 3x10 coarse bit coordinates of one single point.\\n//    medium: array<u32>, // each u32 element has the 3x10 medium bit coordinates of one single point\\n//    high: array<u32>,   // each u32 element has the 3x10 medium bit coordinates of one single point\\n//    color: array<u32>,  // each u32 element has the color of one single point\\n//}\\n\\n// The factor is used to convert the 30 bit integer coordinates to float coordinates using the batch origin and size.\\nconst factor = 1073741823.0; // 0b0011_1111_1111_1111_1111_1111_1111_1111\\n\\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\\n@group(0) @binding(1) var<storage, read_write> depthBuffer: array<atomic<u32>>;\\n\\n/*C*/@group(0) @binding(2) var<storage, read> courseBuffer: array<u32>;\\n/*M*/@group(0) @binding(3) var<storage, read> mediumBuffer: array<u32>;\\n/*F*/@group(0) @binding(4) var<storage, read> fineBuffer: array<u32>;\\n// We don't need the color buffer for depth computation.\\n\\n@compute @workgroup_size(64, 1, 1)\\nfn main(\\n    @builtin(global_invocation_id) gid: vec3<u32>,\\n    @builtin(workgroup_id) wid: vec3<u32>,\\n    @builtin(num_workgroups) num_wg: vec3<u32>\\n) {\\n    let renderMode = uniforms.renderingInfo.x;\\n    let tpw = u32(uniforms.renderingInfo.y);\\n\\n    let pointIndex = gid.y * num_wg.x * tpw + gid.x;\\n    var p = vec3<u32>(0, 0, 0);\\n//    /*C*/p = coarse(pointIndex);\\n//    /*M*/p = medium(pointIndex);\\n//    /*F*/p = fine(pointIndex);\\n    p = transform(pointIndex);\\n\\n    let X = f32(p.x) * f32(uniforms.size.x / factor) + uniforms.origin.x;\\n    let Y = f32(p.y) * f32(uniforms.size.y / factor) + uniforms.origin.y;\\n    let Z = f32(p.z) * f32(uniforms.size.z / factor) + uniforms.origin.z;\\n\\n    let pos = uniforms.mvp * vec4<f32>(X, Y, Z, 1.0);\\n    let w = pos.w;\\n    let ndc = pos / pos.w;\\n\\n    // Discard points behind the camera.\\n    if (w < 0.0) {\\n        return;\\n    }\\n\\n    // Convert ndc to screen space coordinates.\\n    let screen_x = (ndc.x * 0.5 + 0.5) * uniforms.canvas_size.x;\\n    let screen_y = (ndc.y * 0.5 + 0.5) * uniforms.canvas_size.y;\\n\\n    // Discard points outside the screen.\\n    if (screen_x < 0.0 || screen_x >= uniforms.canvas_size.x) {\\n        return;\\n    }\\n    if (screen_y < 0.0 || screen_y >= uniforms.canvas_size.y) {\\n        return;\\n    }\\n\\n    // Calculate the index into the output buffer using the canvas size\\n    let index = u32(screen_y) * u32(uniforms.canvas_size.x) + u32(screen_x);\\n\\n    // compute depth\\n    let uint_depth = bitcast<u32>(w);\\n    atomicMin(&depthBuffer[index], uint_depth); // atomic min will do the calculation and store the result in depthBuffer[index].\\n}\\n\\n// Unraveling the bit packed coordinates.\\n/*fn_C*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x = u32(x_coarse << 20);\\n    let y = u32(y_coarse << 20);\\n    let z = u32(z_coarse << 20);\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\\n\\n/*fn_M*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n    let mediumbits = mediumBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x_medium = u32((mediumbits >> 20) & 0x3FF);\\n    let y_medium = u32((mediumbits >> 10) & 0x3FF);\\n    let z_medium = u32((mediumbits >> 0) & 0x3FF);\\n\\n    let x = (x_coarse << 20) | (x_medium << 10);\\n    let y = (y_coarse << 20) | (y_medium << 10);\\n    let z = (z_coarse << 20) | (z_medium << 10);\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\\n\\n/*fn_F*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n    let mediumbits = mediumBuffer[pointIndex];\\n    let finebits = fineBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x_medium = u32((mediumbits >> 20) & 0x3FF);\\n    let y_medium = u32((mediumbits >> 10) & 0x3FF);\\n    let z_medium = u32((mediumbits >> 0) & 0x3FF);\\n\\n    let x_fine = u32((finebits >> 20) & 0x3FF);\\n    let y_fine = u32((finebits >> 10) & 0x3FF);\\n    let z_fine = u32((finebits >> 0) & 0x3FF);\\n\\n    let x = (x_coarse << 20) | (x_medium << 10) | x_fine;\\n    let y = (y_coarse << 20) | (y_medium << 10) | y_fine;\\n    let z = (z_coarse << 20) | (z_medium << 10) | z_fine;\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\");\n\n//# sourceURL=webpack://point_cloud_renderer/./src/shaders/compute_depth_shader_multipleBuffers.wgsl?");

/***/ }),

/***/ "./src/shaders/compute_multipleBuffers.wgsl":
/*!**************************************************!*\
  !*** ./src/shaders/compute_multipleBuffers.wgsl ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"// ts: [mVP_uniformBuffer, pointsBuffer, framebuffer, depthBuffer]\\nstruct Uniforms {\\n    canvas_size: vec4<f32>,\\n    mvp: mat4x4<f32>,\\n    origin: vec4<f32>,\\n    size: vec4<f32>,\\n    renderingInfo: vec4<f32>,\\n};\\n\\n//struct Point {\\n//    x: f32,\\n//    y: f32,\\n//    z: f32,\\n////    color: uint32_t,\\n//    color: u32,\\n//};\\n\\n//const factor = 4294967296.0; // 2^32\\n//const factor = 2147483648.0; // 2^31\\nconst factor = 1073741824; // 2^30\\n\\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\\n@group(0) @binding(1) var<storage, read_write> depthBuffer: array<atomic<u32>>;\\n@group(0) @binding(2) var<storage, read_write> frameBuffer: array<atomic<u32>>;\\n\\n// BUFFERS\\n@group(0) @binding(3) var<storage, read> colorBuffer: array<u32>;\\n/*C*/@group(0) @binding(4) var<storage, read> courseBuffer: array<u32>;\\n/*M*/@group(0) @binding(5) var<storage, read> mediumBuffer: array<u32>;\\n/*F*/@group(0) @binding(6) var<storage, read> fineBuffer: array<u32>;\\n\\n@compute @workgroup_size(64, 1, 1)\\nfn main(\\n    @builtin(global_invocation_id) gid: vec3<u32>,\\n    @builtin(workgroup_id) wid: vec3<u32>,\\n    @builtin(num_workgroups) num_wg: vec3<u32>\\n) {\\n    let renderMode = uniforms.renderingInfo.x;\\n    let tpw = u32(uniforms.renderingInfo.y);\\n\\n    let pointIndex = gid.y * num_wg.x * tpw + gid.x;\\n    var p = vec3<u32>(0, 0, 0);\\n//    /*C*/p = coarse(pointIndex);\\n//    /*M*/p = medium(pointIndex);\\n//    /*F*/p = fine(pointIndex);\\n    p = transform(pointIndex);\\n\\n    let X = f32(p.x) * f32(uniforms.size.x / factor) + uniforms.origin.x;\\n    let Y = f32(p.y) * f32(uniforms.size.y / factor) + uniforms.origin.y;\\n    let Z = f32(p.z) * f32(uniforms.size.z / factor) + uniforms.origin.z;\\n\\n    let color = colorBuffer[pointIndex];\\n\\n    let pos = uniforms.mvp * vec4<f32>(X, Y, Z, 1.0);\\n\\n    // convert pos to ndc\\n    let w = pos.w;\\n    let ndc = pos / pos.w;\\n\\n    // Discard points behind the camera.\\n    if (w < 0.0) {\\n        return;\\n    }\\n\\n    // Convert ndc to screen space coordinates\\n    let screen_x = (ndc.x * 0.5 + 0.5) * uniforms.canvas_size.x;\\n    let screen_y = (ndc.y * 0.5 + 0.5) * uniforms.canvas_size.y;\\n\\n    // Discard\\n    if (screen_x < 0.0 || screen_x >= uniforms.canvas_size.x) {\\n        return;\\n    }\\n    if (screen_y < 0.0 || screen_y >= uniforms.canvas_size.y) {\\n        return;\\n    }\\n\\n    // Calculate the index into the output buffer using the canvas size\\n    let index = u32(screen_y) * u32(uniforms.canvas_size.x) + u32(screen_x);\\n\\n    // Depth with bitcast\\n    let minDepth_u32 = atomicLoad(&depthBuffer[index]);\\n    let minDepth = bitcast<f32>(minDepth_u32);\\n\\n    // Compute threshold to be 2% more than the minimum depth.\\n    // So 2% of points further away from the minimum value will be kept and the rest discarded.\\n    let depthThreshold = minDepth * 1.001;\\n\\n    // Discard points further away then the depth threshold.\\n    if (w > depthThreshold) {\\n        return;\\n    }\\n\\n    // atomic operations adding up the color values. The accumulated values will later be averaged.\\n    atomicAdd(&frameBuffer[index * 4 + 0], (color >> 16) & 0xFF); // r\\n    atomicAdd(&frameBuffer[index * 4 + 1], (color >> 8) & 0xFF); // g\\n    atomicAdd(&frameBuffer[index * 4 + 2], (color >> 0) & 0xFF); // b\\n    // The alpha channel holds the number of points that contributed to the pixel.\\n    atomicAdd(&frameBuffer[index * 4 + 3], 1); // a\\n}\\n\\n\\n// Unraveling the bit packed coordinates.\\n/*fn_C*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x = u32(x_coarse << 20);\\n    let y = u32(y_coarse << 20);\\n    let z = u32(z_coarse << 20);\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\\n\\n/*fn_M*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n    let mediumbits = mediumBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x_medium = u32((mediumbits >> 20) & 0x3FF);\\n    let y_medium = u32((mediumbits >> 10) & 0x3FF);\\n    let z_medium = u32((mediumbits >> 0) & 0x3FF);\\n\\n    let x = (x_coarse << 20) | (x_medium << 10);\\n    let y = (y_coarse << 20) | (y_medium << 10);\\n    let z = (z_coarse << 20) | (z_medium << 10);\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\\n\\n/*fn_F*/\\nfn transform(pointIndex: u32) -> vec3<u32> {\\n    let coarsebits = courseBuffer[pointIndex];\\n    let mediumbits = mediumBuffer[pointIndex];\\n    let finebits = fineBuffer[pointIndex];\\n\\n    // X, Y and Z are 10 bit integer coordinates, each with 1024 possible values\\n    let x_coarse = u32((coarsebits >> 20) & 0x3FF);\\n    let y_coarse = u32((coarsebits >> 10) & 0x3FF);\\n    let z_coarse = u32((coarsebits >> 0) & 0x3FF);\\n\\n    let x_medium = u32((mediumbits >> 20) & 0x3FF);\\n    let y_medium = u32((mediumbits >> 10) & 0x3FF);\\n    let z_medium = u32((mediumbits >> 0) & 0x3FF);\\n\\n    let x_fine = u32((finebits >> 20) & 0x3FF);\\n    let y_fine = u32((finebits >> 10) & 0x3FF);\\n    let z_fine = u32((finebits >> 0) & 0x3FF);\\n\\n    let x = (x_coarse << 20) | (x_medium << 10) | x_fine;\\n    let y = (y_coarse << 20) | (y_medium << 10) | y_fine;\\n    let z = (z_coarse << 20) | (z_medium << 10) | z_fine;\\n\\n    return vec3<u32>(x, y, z);\\n}\\n/*fn_end*/\");\n\n//# sourceURL=webpack://point_cloud_renderer/./src/shaders/compute_multipleBuffers.wgsl?");

/***/ }),

/***/ "./src/shaders/display_on_screan.wgsl":
/*!********************************************!*\
  !*** ./src/shaders/display_on_screan.wgsl ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"struct VertexIn {\\n    @location(0) position: vec4<f32>,\\n    @location(1) uv: vec2<f32>,\\n}\\n\\nstruct Fragment {\\n    @builtin(position) Position: vec4<f32>,\\n    @location(0) fragUV : vec2f,\\n};\\n\\nstruct Uniforms {\\n    canvas_size: vec2<f32>,\\n    mvp: mat4x4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\\n@group(0) @binding(1) var<storage, read_write> inputBuffer: array<atomic<u32>>;\\n\\n@vertex\\nfn vs_main(v: VertexIn) -> Fragment {\\n    var output = Fragment();\\n    output.Position = v.position;\\n    output.fragUV = v.uv;\\n    return output;\\n}\\n\\n@fragment\\nfn fs_main(f: Fragment) -> @location(0) vec4<f32> {\\n    let width = uniforms.canvas_size.x;\\n    let height = uniforms.canvas_size.y;\\n\\n    let screen_x = u32(f.fragUV.x * width);\\n    let screen_y = u32(f.fragUV.y * height);\\n\\n    let index = screen_y * u32(width) + screen_x;\\n\\n    // load the aggregate color values.\\n    let r = atomicLoad(&inputBuffer[index * 4 + 0]);\\n    let g = atomicLoad(&inputBuffer[index * 4 + 1]);\\n    let b = atomicLoad(&inputBuffer[index * 4 + 2]);\\n    // The alpha channel holds the number of points that contributed to the pixel.\\n    let a = atomicLoad(&inputBuffer[index * 4 + 3]);\\n\\n    // Compute average color using the accumulated values and the number of points.\\n    let divider = f32(a) * 255.0;\\n    let color = vec4<f32>(\\n        f32(r) / divider,\\n        f32(g) / divider,\\n        f32(b) / divider,\\n        1.0\\n    );\\n\\n    return color;\\n}\");\n\n//# sourceURL=webpack://point_cloud_renderer/./src/shaders/display_on_screan.wgsl?");

/***/ }),

/***/ "./src/utils/TimingHelper.js":
/*!***********************************!*\
  !*** ./src/utils/TimingHelper.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TimingHelper)\n/* harmony export */ });\n// TAKEN FROM WEB GPU FUNDAMENTALS:\n// https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html\n//\n\nfunction assert(cond, msg = '') {\n    if (!cond) {\n        throw new Error(msg);\n    }\n}\n\n// We track command buffers so we can generate an error if\n// we try to read the result before the command buffer has been executed.\nconst s_unsubmittedCommandBuffer = new Set();\n\n/* global GPUQueue */\nGPUQueue.prototype.submit = (function(origFn) {\n    return function(commandBuffers) {\n        origFn.call(this, commandBuffers);\n        commandBuffers.forEach(cb => s_unsubmittedCommandBuffer.delete(cb));\n    };\n})(GPUQueue.prototype.submit);\n\n// See https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html\nclass TimingHelper {\n    #canTimestamp;\n    #device;\n    #querySet;\n    #resolveBuffer;\n    #resultBuffer;\n    #commandBuffer;\n    #resultBuffers = [];\n    // state can be 'free', 'need resolve', 'wait for result'\n    #state = 'free';\n\n    constructor(device) {\n        this.#device = device;\n        this.#canTimestamp = device.features.has('timestamp-query');\n        if (this.#canTimestamp) {\n            this.#querySet = device.createQuerySet({\n                type: 'timestamp',\n                count: 2,\n            });\n            this.#resolveBuffer = device.createBuffer({\n                size: this.#querySet.count * 8,\n                usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n            });\n        }\n    }\n    #beginTimestampPass(encoder, fnName, descriptor) {\n        if (this.#canTimestamp) {\n            assert(this.#state === 'free', 'state not free');\n            this.#state = 'need resolve';\n\n            const pass = encoder[fnName]({\n                ...descriptor,\n                ...{\n                    timestampWrites: {\n                        querySet: this.#querySet,\n                        beginningOfPassWriteIndex: 0,\n                        endOfPassWriteIndex: 1,\n                    },\n                },\n            });\n\n            const resolve = () => this.#resolveTiming(encoder);\n            const trackCommandBuffer = (cb) => this.#trackCommandBuffer(cb);\n            pass.end = (function(origFn) {\n                return function() {\n                    origFn.call(this);\n                    resolve();\n                };\n            })(pass.end);\n\n            encoder.finish = (function(origFn) {\n                return function() {\n                    const cb = origFn.call(this);\n                    trackCommandBuffer(cb);\n                    return cb;\n                };\n            })(encoder.finish);\n\n            return pass;\n        } else {\n            return encoder[fnName](descriptor);\n        }\n    }\n\n    beginRenderPass(encoder, descriptor = {}) {\n        return this.#beginTimestampPass(encoder, 'beginRenderPass', descriptor);\n    }\n\n    beginComputePass(encoder, descriptor = {}) {\n        return this.#beginTimestampPass(encoder, 'beginComputePass', descriptor);\n    }\n\n    #trackCommandBuffer(cb) {\n        if (!this.#canTimestamp) {\n            return;\n        }\n        assert(this.#state === 'need finish', 'you must call encoder.finish');\n        this.#commandBuffer = cb;\n        s_unsubmittedCommandBuffer.add(cb);\n        this.#state = 'wait for result';\n    }\n\n    #resolveTiming(encoder) {\n        if (!this.#canTimestamp) {\n            return;\n        }\n        assert(\n            this.#state === 'need resolve',\n            'you must use timerHelper.beginComputePass or timerHelper.beginRenderPass',\n        );\n        this.#state = 'need finish';\n\n        this.#resultBuffer = this.#resultBuffers.pop() || this.#device.createBuffer({\n            size: this.#resolveBuffer.size,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n        });\n\n        encoder.resolveQuerySet(this.#querySet, 0, this.#querySet.count, this.#resolveBuffer, 0);\n        encoder.copyBufferToBuffer(this.#resolveBuffer, 0, this.#resultBuffer, 0, this.#resultBuffer.size);\n    }\n\n    async getResult() {\n        if (!this.#canTimestamp) {\n            return 0;\n        }\n        assert(\n            this.#state === 'wait for result',\n            'you must call encoder.finish and submit the command buffer before you can read the result',\n        );\n        assert(!!this.#commandBuffer); // internal check\n        assert(\n            !s_unsubmittedCommandBuffer.has(this.#commandBuffer),\n            'you must submit the command buffer before you can read the result',\n        );\n        this.#commandBuffer = undefined;\n        this.#state = 'free';\n\n        const resultBuffer = this.#resultBuffer;\n        await resultBuffer.mapAsync(GPUMapMode.READ);\n        const times = new BigInt64Array(resultBuffer.getMappedRange());\n        const duration = Number(times[1] - times[0]);\n        resultBuffer.unmap();\n        this.#resultBuffers.push(resultBuffer);\n        return duration;\n    }\n}\n\n//# sourceURL=webpack://point_cloud_renderer/./src/utils/TimingHelper.js?");

/***/ }),

/***/ "./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mat3: () => (/* binding */ mat3Impl),\n/* harmony export */   mat4: () => (/* binding */ mat4Impl),\n/* harmony export */   setDefaultType: () => (/* binding */ setDefaultType),\n/* harmony export */   types: () => (/* binding */ arrayLike),\n/* harmony export */   utils: () => (/* binding */ utils),\n/* harmony export */   vec2: () => (/* binding */ vec2Impl),\n/* harmony export */   vec3: () => (/* binding */ vec3Impl),\n/* harmony export */   vec4: () => (/* binding */ vec4Impl)\n/* harmony export */ });\n/* wgpu-matrix@1.0.0, license MIT */\nvar arrayLike = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$3(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    setEpsilon: setEpsilon,\n    degToRad: degToRad,\n    radToDeg: radToDeg,\n    lerp: lerp$3,\n    inverseLerp: inverseLerp,\n    euclideanModulo: euclideanModulo\n});\n\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$4(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$2 = create$4;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nconst scale$4 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$4;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$2(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nfunction copy$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nconst clone$4 = copy$4;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$4,\n    setDefaultType: setDefaultType$5,\n    fromValues: fromValues$2,\n    ceil: ceil$2,\n    floor: floor$2,\n    round: round$2,\n    clamp: clamp$2,\n    add: add$2,\n    addScaled: addScaled$2,\n    angle: angle$1,\n    subtract: subtract$2,\n    sub: sub$2,\n    equalsApproximately: equalsApproximately$4,\n    equals: equals$4,\n    lerp: lerp$2,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mulScalar: mulScalar$2,\n    scale: scale$4,\n    divScalar: divScalar$2,\n    inverse: inverse$4,\n    invert: invert$4,\n    cross: cross$1,\n    dot: dot$2,\n    length: length$2,\n    len: len$2,\n    lengthSq: lengthSq$2,\n    lenSq: lenSq$2,\n    distance: distance$2,\n    dist: dist$2,\n    distanceSq: distanceSq$2,\n    distSq: distSq$2,\n    normalize: normalize$2,\n    negate: negate$4,\n    copy: copy$4,\n    clone: clone$4,\n    multiply: multiply$4,\n    mul: mul$4,\n    divide: divide$2,\n    div: div$2,\n    random: random$1,\n    zero: zero$2,\n    transformMat4: transformMat4$2,\n    transformMat3: transformMat3$1\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$3(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$3 = copy$3;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$3(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m11_x_m22 = m11 * m22;\n    const m21_x_m12 = m21 * m12;\n    const m01_x_m22 = m01 * m22;\n    const m21_x_m02 = m21 * m02;\n    const m01_x_m12 = m01 * m12;\n    const m11_x_m02 = m11 * m02;\n    const invDet = 1 / (m00 * (m11_x_m22 - m21_x_m12) -\n        m10 * (m01_x_m22 - m21_x_m02) +\n        m20 * (m01_x_m12 - m11_x_m02));\n    dst[0] = +(m11_x_m22 - m21_x_m12) * invDet;\n    dst[1] = -(m10 * m22 - m20 * m12) * invDet;\n    dst[2] = +(m10 * m21 - m20 * m11) * invDet;\n    dst[4] = -(m01_x_m22 - m21_x_m02) * invDet;\n    dst[5] = +(m00 * m22 - m20 * m02) * invDet;\n    dst[6] = -(m00 * m21 - m20 * m01) * invDet;\n    dst[8] = +(m01_x_m12 - m11_x_m02) * invDet;\n    dst[9] = -(m00 * m12 - m10 * m02) * invDet;\n    dst[10] = +(m00 * m11 - m10 * m01) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$3;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || create$4();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || create$4();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$3(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || create$4();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$3(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$4,\n    create: create$3,\n    negate: negate$3,\n    copy: copy$3,\n    clone: clone$3,\n    equalsApproximately: equalsApproximately$3,\n    equals: equals$3,\n    identity: identity$1,\n    transpose: transpose$1,\n    inverse: inverse$3,\n    determinant: determinant$1,\n    invert: invert$3,\n    multiply: multiply$3,\n    mul: mul$3,\n    setTranslation: setTranslation$1,\n    getTranslation: getTranslation$1,\n    getAxis: getAxis$1,\n    setAxis: setAxis$1,\n    getScaling: getScaling$1,\n    translation: translation$1,\n    translate: translate$1,\n    rotation: rotation$1,\n    rotate: rotate$1,\n    scaling: scaling$1,\n    scale: scale$3\n});\n\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$2(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$1 = create$2;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$1(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nconst scale$2 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$2;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nfunction copy$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nconst clone$2 = copy$2;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    create: create$2,\n    setDefaultType: setDefaultType$3,\n    fromValues: fromValues$1,\n    ceil: ceil$1,\n    floor: floor$1,\n    round: round$1,\n    clamp: clamp$1,\n    add: add$1,\n    addScaled: addScaled$1,\n    angle: angle,\n    subtract: subtract$1,\n    sub: sub$1,\n    equalsApproximately: equalsApproximately$2,\n    equals: equals$2,\n    lerp: lerp$1,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mulScalar: mulScalar$1,\n    scale: scale$2,\n    divScalar: divScalar$1,\n    inverse: inverse$2,\n    invert: invert$2,\n    cross: cross,\n    dot: dot$1,\n    length: length$1,\n    len: len$1,\n    lengthSq: lengthSq$1,\n    lenSq: lenSq$1,\n    distance: distance$1,\n    dist: dist$1,\n    distanceSq: distanceSq$1,\n    distSq: distSq$1,\n    normalize: normalize$1,\n    negate: negate$2,\n    copy: copy$2,\n    clone: clone$2,\n    multiply: multiply$2,\n    mul: mul$2,\n    divide: divide$1,\n    div: div$1,\n    random: random,\n    zero: zero$1,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    transformMat3: transformMat3\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$1(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$1 = copy$1;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$1(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$1;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$1 = multiply$1;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$2();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$2();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$1(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$2();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    const rangeInv = 1 / (zNear - zFar);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = zFar * rangeInv;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = zNear * zFar * rangeInv;\n    dst[15] = 0;\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 look-at transformation.\n *\n * This is a matrix which positions the camera itself. If you want\n * a view matrix (a matrix which moves things in front of the camera)\n * take the inverse of this.\n *\n * @param eye - The position of the eye.\n * @param target - The position meant to be viewed.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$2();\n    yAxis = yAxis || create$2();\n    zAxis = zAxis || create$2();\n    normalize$1(subtract$1(eye, target, zAxis), zAxis);\n    normalize$1(cross(up, zAxis, xAxis), xAxis);\n    normalize$1(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$1(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$2,\n    create: create$1,\n    negate: negate$1,\n    copy: copy$1,\n    clone: clone$1,\n    equalsApproximately: equalsApproximately$1,\n    equals: equals$1,\n    identity: identity,\n    transpose: transpose,\n    inverse: inverse$1,\n    determinant: determinant,\n    invert: invert$1,\n    multiply: multiply$1,\n    mul: mul$1,\n    setTranslation: setTranslation,\n    getTranslation: getTranslation,\n    getAxis: getAxis,\n    setAxis: setAxis,\n    getScaling: getScaling,\n    perspective: perspective,\n    ortho: ortho,\n    frustum: frustum,\n    lookAt: lookAt,\n    translation: translation,\n    translate: translate,\n    rotationX: rotationX,\n    rotateX: rotateX,\n    rotationY: rotationY,\n    rotateY: rotateY,\n    rotationZ: rotationZ,\n    rotateZ: rotateZ,\n    axisRotation: axisRotation,\n    rotation: rotation,\n    axisRotate: axisRotate,\n    rotate: rotate,\n    scaling: scaling,\n    scale: scale$1\n});\n\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, 'Float64Array', or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    setDefaultType: setDefaultType$1,\n    create: create,\n    fromValues: fromValues,\n    ceil: ceil,\n    floor: floor,\n    round: round,\n    clamp: clamp,\n    add: add,\n    addScaled: addScaled,\n    subtract: subtract,\n    sub: sub,\n    equalsApproximately: equalsApproximately,\n    equals: equals,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mulScalar: mulScalar,\n    scale: scale,\n    divScalar: divScalar,\n    inverse: inverse,\n    invert: invert,\n    dot: dot,\n    length: length,\n    len: len,\n    lengthSq: lengthSq,\n    lenSq: lenSq,\n    distance: distance,\n    dist: dist,\n    distanceSq: distanceSq,\n    distSq: distSq,\n    normalize: normalize,\n    negate: negate,\n    copy: copy,\n    clone: clone,\n    multiply: multiply,\n    mul: mul,\n    divide: divide,\n    div: div,\n    zero: zero,\n    transformMat4: transformMat4\n});\n\n/**\n * Sets the type this library creates for all types\n * @remarks\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$4(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$5(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$1(ctor);\n}\n\n\n//# sourceMappingURL=wgpu-matrix.module.js.map\n\n\n//# sourceURL=webpack://point_cloud_renderer/./node_modules/webgpu-matrix/dist/1.x/wgpu-matrix.module.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "dist/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;